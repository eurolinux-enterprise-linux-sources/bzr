/* Generated by Cython 0.14.1 on Mon Jan 16 15:59:40 2012 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#else

#include <stddef.h> /* For offsetof */
#ifndef offsetof
#define offsetof(type, member) ( (size_t) & ((type*)0) -> member )
#endif

#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#endif

#ifndef DL_IMPORT
  #define DL_IMPORT(t) t
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif

#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif

#if PY_VERSION_HEX < 0x02040000
  #define METH_COEXIST 0
  #define PyDict_CheckExact(op) (Py_TYPE(op) == &PyDict_Type)
  #define PyDict_Contains(d,o)   PySequence_Contains(d,o)
#endif

#if PY_VERSION_HEX < 0x02050000
  typedef int Py_ssize_t;
  #define PY_SSIZE_T_MAX INT_MAX
  #define PY_SSIZE_T_MIN INT_MIN
  #define PY_FORMAT_SIZE_T ""
  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
  #define PyInt_AsSsize_t(o)   PyInt_AsLong(o)
  #define PyNumber_Index(o)    PyNumber_Int(o)
  #define PyIndex_Check(o)     PyNumber_Check(o)
  #define PyErr_WarnEx(category, message, stacklevel) PyErr_Warn(category, message)
#endif

#if PY_VERSION_HEX < 0x02060000
  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
  #define PyVarObject_HEAD_INIT(type, size) \
          PyObject_HEAD_INIT(type) size,
  #define PyType_Modified(t)

  typedef struct {
     void *buf;
     PyObject *obj;
     Py_ssize_t len;
     Py_ssize_t itemsize;
     int readonly;
     int ndim;
     char *format;
     Py_ssize_t *shape;
     Py_ssize_t *strides;
     Py_ssize_t *suboffsets;
     void *internal;
  } Py_buffer;

  #define PyBUF_SIMPLE 0
  #define PyBUF_WRITABLE 0x0001
  #define PyBUF_FORMAT 0x0004
  #define PyBUF_ND 0x0008
  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)

#endif

#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
#endif

#if PY_MAJOR_VERSION >= 3
  #define Py_TPFLAGS_CHECKTYPES 0
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif

#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif

#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyStringObject               PyUnicodeObject
  #define PyString_Type                PyUnicode_Type
  #define PyString_Check               PyUnicode_Check
  #define PyString_CheckExact          PyUnicode_CheckExact
#endif

#if PY_VERSION_HEX < 0x02060000
  #define PyBytesObject                PyStringObject
  #define PyBytes_Type                 PyString_Type
  #define PyBytes_Check                PyString_Check
  #define PyBytes_CheckExact           PyString_CheckExact
  #define PyBytes_FromString           PyString_FromString
  #define PyBytes_FromStringAndSize    PyString_FromStringAndSize
  #define PyBytes_FromFormat           PyString_FromFormat
  #define PyBytes_DecodeEscape         PyString_DecodeEscape
  #define PyBytes_AsString             PyString_AsString
  #define PyBytes_AsStringAndSize      PyString_AsStringAndSize
  #define PyBytes_Size                 PyString_Size
  #define PyBytes_AS_STRING            PyString_AS_STRING
  #define PyBytes_GET_SIZE             PyString_GET_SIZE
  #define PyBytes_Repr                 PyString_Repr
  #define PyBytes_Concat               PyString_Concat
  #define PyBytes_ConcatAndDel         PyString_ConcatAndDel
#endif

#if PY_VERSION_HEX < 0x02060000
  #define PySet_Check(obj)             PyObject_TypeCheck(obj, &PySet_Type)
  #define PyFrozenSet_Check(obj)       PyObject_TypeCheck(obj, &PyFrozenSet_Type)
#endif
#ifndef PySet_CheckExact
  #define PySet_CheckExact(obj)        (Py_TYPE(obj) == &PySet_Type)
#endif

#define __Pyx_TypeCheck(obj, type) PyObject_TypeCheck(obj, (PyTypeObject *)type)

#if PY_MAJOR_VERSION >= 3
  #define PyIntObject                  PyLongObject
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
#endif

#if PY_MAJOR_VERSION >= 3
  #define PyBoolObject                 PyLongObject
#endif


#if PY_MAJOR_VERSION >= 3
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceTrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define __Pyx_PyNumber_InPlaceDivide(x,y)  PyNumber_InPlaceDivide(x,y)
#endif

#if (PY_MAJOR_VERSION < 3) || (PY_VERSION_HEX >= 0x03010300)
  #define __Pyx_PySequence_GetSlice(obj, a, b) PySequence_GetSlice(obj, a, b)
  #define __Pyx_PySequence_SetSlice(obj, a, b, value) PySequence_SetSlice(obj, a, b, value)
  #define __Pyx_PySequence_DelSlice(obj, a, b) PySequence_DelSlice(obj, a, b)
#else
  #define __Pyx_PySequence_GetSlice(obj, a, b) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), (PyObject*)0) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_GetSlice(obj, a, b)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object is unsliceable", (obj)->ob_type->tp_name), (PyObject*)0)))
  #define __Pyx_PySequence_SetSlice(obj, a, b, value) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_SetSlice(obj, a, b, value)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice assignment", (obj)->ob_type->tp_name), -1)))
  #define __Pyx_PySequence_DelSlice(obj, a, b) (unlikely(!(obj)) ? \
        (PyErr_SetString(PyExc_SystemError, "null argument to internal routine"), -1) : \
        (likely((obj)->ob_type->tp_as_mapping) ? (PySequence_DelSlice(obj, a, b)) : \
            (PyErr_Format(PyExc_TypeError, "'%.200s' object doesn't support slice deletion", (obj)->ob_type->tp_name), -1)))
#endif

#if PY_MAJOR_VERSION >= 3
  #define PyMethod_New(func, self, klass) ((self) ? PyMethod_New(func, self) : PyInstanceMethod_New(func))
#endif

#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
#else
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
#endif

#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_NAMESTR(n) ((char *)(n))
  #define __Pyx_DOCSTR(n)  ((char *)(n))
#else
  #define __Pyx_NAMESTR(n) (n)
  #define __Pyx_DOCSTR(n)  (n)
#endif

#ifdef __cplusplus
#define __PYX_EXTERN_C extern "C"
#else
#define __PYX_EXTERN_C extern
#endif

#if defined(WIN32) || defined(MS_WINDOWS)
#define _USE_MATH_DEFINES
#endif
#include <math.h>
#define __PYX_HAVE_API__bzrlib___simple_set_pyx
#include "python-compat.h"

#ifdef PYREX_WITHOUT_ASSERTIONS
#define CYTHON_WITHOUT_ASSERTIONS
#endif


/* inline attribute */
#ifndef CYTHON_INLINE
  #if defined(__GNUC__)
    #define CYTHON_INLINE __inline__
  #elif defined(_MSC_VER)
    #define CYTHON_INLINE __inline
  #elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
    #define CYTHON_INLINE inline
  #else
    #define CYTHON_INLINE
  #endif
#endif

/* unused attribute */
#ifndef CYTHON_UNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define CYTHON_UNUSED __attribute__ ((__unused__))
#   else
#     define CYTHON_UNUSED
#   endif
# elif defined(__ICC) || defined(__INTEL_COMPILER)
#   define CYTHON_UNUSED __attribute__ ((__unused__))
# else
#   define CYTHON_UNUSED
# endif
#endif

typedef struct {PyObject **p; char *s; const long n; const char* encoding; const char is_unicode; const char is_str; const char intern; } __Pyx_StringTabEntry; /*proto*/


/* Type Conversion Predeclarations */

#define __Pyx_PyBytes_FromUString(s) PyBytes_FromString((char*)s)
#define __Pyx_PyBytes_AsUString(s)   ((unsigned char*) PyBytes_AsString(s))

#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);

static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);

#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))


#ifdef __GNUC__
/* Test for GCC > 2.95 */
#if __GNUC__ > 2 || (__GNUC__ == 2 && (__GNUC_MINOR__ > 95))
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
#else /* __GNUC__ > 2 ... */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ > 2 ... */
#else /* __GNUC__ */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ */
    
static PyObject *__pyx_m;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static PyObject *__pyx_empty_bytes;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;


static const char *__pyx_f[] = {
  "_simple_set_pyx.pyx",
};

/* Type declarations */

/* "bzrlib/_simple_set_pyx.pyx":361
 * 
 * 
 * cdef class _SimpleSet_iterator:             # <<<<<<<<<<<<<<
 *     """Iterator over the SimpleSet structure."""
 * 
 */

struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator {
  PyObject_HEAD
  Py_ssize_t pos;
  struct SimpleSetObject *set;
  Py_ssize_t _used;
  Py_ssize_t len;
};

/* "bzrlib/_simple_set_pyx.pxd":31
 * 
 * 
 * cdef public api class SimpleSet [object SimpleSetObject, type SimpleSet_Type]:             # <<<<<<<<<<<<<<
 *     """A class similar to PySet, but with simpler implementation.
 * 
 */

struct SimpleSetObject {
  PyObject_HEAD
  struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet *__pyx_vtab;
  Py_ssize_t _used;
  Py_ssize_t _fill;
  Py_ssize_t _mask;
  PyObject **_table;
};

__PYX_EXTERN_C DL_EXPORT(PyTypeObject) SimpleSet_Type;

/* "bzrlib/_simple_set_pyx.pyx":88
 * 
 * 
 * cdef public api class SimpleSet [object SimpleSetObject, type SimpleSet_Type]:             # <<<<<<<<<<<<<<
 *     """This class can be used to track canonical forms for objects.
 * 
 */

struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet {
  PyObject *(*_get)(struct SimpleSetObject *, PyObject *);
  PyObject *(*_add)(struct SimpleSetObject *, PyObject *);
  int (*_discard)(struct SimpleSetObject *, PyObject *);
  int (*_insert_clean)(struct SimpleSetObject *, PyObject *);
  Py_ssize_t (*_resize)(struct SimpleSetObject *, Py_ssize_t);
};
static struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet *__pyx_vtabptr_6bzrlib_15_simple_set_pyx_SimpleSet;

#ifndef CYTHON_REFNANNY
  #define CYTHON_REFNANNY 0
#endif

#if CYTHON_REFNANNY
  typedef struct {
    void (*INCREF)(void*, PyObject*, int);
    void (*DECREF)(void*, PyObject*, int);
    void (*GOTREF)(void*, PyObject*, int);
    void (*GIVEREF)(void*, PyObject*, int);
    void* (*SetupContext)(const char*, int, const char*);
    void (*FinishContext)(void**);
  } __Pyx_RefNannyAPIStruct;
  static __Pyx_RefNannyAPIStruct *__Pyx_RefNanny = NULL;
  static __Pyx_RefNannyAPIStruct * __Pyx_RefNannyImportAPI(const char *modname) {
    PyObject *m = NULL, *p = NULL;
    void *r = NULL;
    m = PyImport_ImportModule((char *)modname);
    if (!m) goto end;
    p = PyObject_GetAttrString(m, (char *)"RefNannyAPI");
    if (!p) goto end;
    r = PyLong_AsVoidPtr(p);
  end:
    Py_XDECREF(p);
    Py_XDECREF(m);
    return (__Pyx_RefNannyAPIStruct *)r;
  }
  #define __Pyx_RefNannySetupContext(name)           void *__pyx_refnanny = __Pyx_RefNanny->SetupContext((name), __LINE__, __FILE__)
  #define __Pyx_RefNannyFinishContext()           __Pyx_RefNanny->FinishContext(&__pyx_refnanny)
  #define __Pyx_INCREF(r) __Pyx_RefNanny->INCREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_DECREF(r) __Pyx_RefNanny->DECREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GOTREF(r) __Pyx_RefNanny->GOTREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_GIVEREF(r) __Pyx_RefNanny->GIVEREF(__pyx_refnanny, (PyObject *)(r), __LINE__)
  #define __Pyx_XDECREF(r) do { if((r) != NULL) {__Pyx_DECREF(r);} } while(0)
#else
  #define __Pyx_RefNannySetupContext(name)
  #define __Pyx_RefNannyFinishContext()
  #define __Pyx_INCREF(r) Py_INCREF(r)
  #define __Pyx_DECREF(r) Py_DECREF(r)
  #define __Pyx_GOTREF(r)
  #define __Pyx_GIVEREF(r)
  #define __Pyx_XDECREF(r) Py_XDECREF(r)
#endif /* CYTHON_REFNANNY */
#define __Pyx_XGIVEREF(r) do { if((r) != NULL) {__Pyx_GIVEREF(r);} } while(0)
#define __Pyx_XGOTREF(r) do { if((r) != NULL) {__Pyx_GOTREF(r);} } while(0)

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name); /*proto*/

static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/

static CYTHON_INLINE int __Pyx_CheckKeywordStrings(PyObject *kwdict,
    const char* function_name, int kw_allowed); /*proto*/

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb); /*proto*/

static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name, PyObject* kw_name); /*proto*/

static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],     PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,     const char* function_name); /*proto*/

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type); /*proto*/

static CYTHON_INLINE long __Pyx_NegateNonNeg(long b) { return unlikely(b < 0) ? b : !b; }
static CYTHON_INLINE PyObject* __Pyx_PyBoolOrNull_FromLong(long b) {
    return unlikely(b < 0) ? NULL : __Pyx_PyBool_FromLong(b);
}

static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);

static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);

static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);

static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject *);

static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject *);

static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject *);

static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);

static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);

static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);

static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject *);

static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);

static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);

static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject *);

static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);

static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);

static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);

static int __Pyx_ExportFunction(const char *name, void (*f)(void), const char *sig); /*proto*/

static int __Pyx_SetVtable(PyObject *dict, void *vtable); /*proto*/

static void __Pyx_AddTraceback(const char *funcname); /*proto*/

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/
/* Module declarations from bzrlib._simple_set_pyx */

static PyTypeObject *__pyx_ptype_6bzrlib_15_simple_set_pyx_SimpleSet = 0;
static PyTypeObject *__pyx_ptype_6bzrlib_15_simple_set_pyx__SimpleSet_iterator = 0;
static PyObject *__pyx_v_6bzrlib_15_simple_set_pyx__dummy_obj = 0;
static PyObject *__pyx_v_6bzrlib_15_simple_set_pyx__dummy;
static PyObject *__pyx_v_6bzrlib_15_simple_set_pyx__NotImplemented = 0;
static struct SimpleSetObject *SimpleSet_New(void); /*proto*/
static PyObject *SimpleSet_Add(PyObject *, PyObject *); /*proto*/
static int SimpleSet_Contains(PyObject *, PyObject *); /*proto*/
static int SimpleSet_Discard(PyObject *, PyObject *); /*proto*/
static PyObject *SimpleSet_Get(struct SimpleSetObject *, PyObject *); /*proto*/
static Py_ssize_t SimpleSet_Size(PyObject *); /*proto*/
static int SimpleSet_Next(PyObject *, Py_ssize_t *, PyObject **); /*proto*/
static int __pyx_f_6bzrlib_15_simple_set_pyx__is_equal(PyObject *, long, PyObject *); /*proto*/
static struct SimpleSetObject *__pyx_f_6bzrlib_15_simple_set_pyx__check_self(PyObject *); /*proto*/
static PyObject **__pyx_f_6bzrlib_15_simple_set_pyx__lookup(struct SimpleSetObject *, PyObject *); /*proto*/
static PyObject **_SimpleSet_Lookup(PyObject *, PyObject *); /*proto*/
static int __pyx_f_6bzrlib_15_simple_set_pyx_SimpleSet_traverse(struct SimpleSetObject *, visitproc, void *); /*proto*/
#define __Pyx_MODULE_NAME "bzrlib._simple_set_pyx"
static int __pyx_module_is_main_bzrlib___simple_set_pyx = 0;

/* Implementation of bzrlib._simple_set_pyx */
static PyObject *__pyx_builtin_object;
static PyObject *__pyx_builtin_NotImplemented;
static PyObject *__pyx_builtin_MemoryError;
static PyObject *__pyx_builtin_KeyError;
static PyObject *__pyx_builtin_RuntimeError;
static PyObject *__pyx_builtin_TypeError;
static PyObject *__pyx_builtin_StopIteration;
static PyObject *__pyx_builtin_AssertionError;
static char __pyx_k_1[] = "<null>";
static char __pyx_k_2[] = "<dummy>";
static char __pyx_k_3[] = "Key %s is not present";
static char __pyx_k_4[] = "ran out of slots.";
static char __pyx_k_6[] = "Types added to SimpleSet must implement both tp_richcompare and tp_hash";
static char __pyx_k_8[] = "Set size changed during iteration";
static char __pyx_k_10[] = "self must not be None";
static char __pyx_k_12[] = "should never get here";
static char __pyx_k_14[] = "Definition of a class that is similar to Set with some small changes.";
static char __pyx_k__len[] = "len";
static char __pyx_k__obj[] = "obj";
static char __pyx_k__pos[] = "pos";
static char __pyx_k__set[] = "set";
static char __pyx_k___add[] = "_add";
static char __pyx_k___get[] = "_get";
static char __pyx_k___fill[] = "_fill";
static char __pyx_k___mask[] = "_mask";
static char __pyx_k___used[] = "_used";
static char __pyx_k___table[] = "_table";
static char __pyx_k__object[] = "object";
static char __pyx_k___resize[] = "_resize";
static char __pyx_k__tp_hash[] = "tp_hash";
static char __pyx_k__KeyError[] = "KeyError";
static char __pyx_k____main__[] = "__main__";
static char __pyx_k____test__[] = "__test__";
static char __pyx_k___discard[] = "_discard";
static char __pyx_k__TypeError[] = "TypeError";
static char __pyx_k__MemoryError[] = "MemoryError";
static char __pyx_k__tp_traverse[] = "tp_traverse";
static char __pyx_k__RuntimeError[] = "RuntimeError";
static char __pyx_k__StopIteration[] = "StopIteration";
static char __pyx_k___insert_clean[] = "_insert_clean";
static char __pyx_k__AssertionError[] = "AssertionError";
static char __pyx_k__NotImplemented[] = "NotImplemented";
static char __pyx_k__tp_richcompare[] = "tp_richcompare";
static PyObject *__pyx_kp_s_1;
static PyObject *__pyx_kp_s_10;
static PyObject *__pyx_kp_s_12;
static PyObject *__pyx_kp_s_2;
static PyObject *__pyx_kp_s_3;
static PyObject *__pyx_kp_s_4;
static PyObject *__pyx_kp_s_6;
static PyObject *__pyx_kp_s_8;
static PyObject *__pyx_n_s__AssertionError;
static PyObject *__pyx_n_s__KeyError;
static PyObject *__pyx_n_s__MemoryError;
static PyObject *__pyx_n_s__NotImplemented;
static PyObject *__pyx_n_s__RuntimeError;
static PyObject *__pyx_n_s__StopIteration;
static PyObject *__pyx_n_s__TypeError;
static PyObject *__pyx_n_s____main__;
static PyObject *__pyx_n_s____test__;
static PyObject *__pyx_n_s___add;
static PyObject *__pyx_n_s___discard;
static PyObject *__pyx_n_s___fill;
static PyObject *__pyx_n_s___get;
static PyObject *__pyx_n_s___insert_clean;
static PyObject *__pyx_n_s___mask;
static PyObject *__pyx_n_s___resize;
static PyObject *__pyx_n_s___table;
static PyObject *__pyx_n_s___used;
static PyObject *__pyx_n_s__len;
static PyObject *__pyx_n_s__obj;
static PyObject *__pyx_n_s__object;
static PyObject *__pyx_n_s__pos;
static PyObject *__pyx_n_s__set;
static PyObject *__pyx_n_s__tp_hash;
static PyObject *__pyx_n_s__tp_richcompare;
static PyObject *__pyx_n_s__tp_traverse;
static PyObject *__pyx_int_0;
static PyObject *__pyx_k_tuple_5;
static PyObject *__pyx_k_tuple_7;
static PyObject *__pyx_k_tuple_9;
static PyObject *__pyx_k_tuple_11;
static PyObject *__pyx_k_tuple_13;

/* "bzrlib/_simple_set_pyx.pyx":62
 * 
 * 
 * cdef int _is_equal(PyObject *this, long this_hash, PyObject *other) except -1:             # <<<<<<<<<<<<<<
 *     cdef long other_hash
 * 
 */

static  int __pyx_f_6bzrlib_15_simple_set_pyx__is_equal(PyObject *__pyx_v_this, long __pyx_v_this_hash, PyObject *__pyx_v_other) {
  long __pyx_v_other_hash;
  PyObject *__pyx_v_res;
  int __pyx_r;
  int __pyx_t_1;
  long __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("_is_equal");
  __pyx_v_res = Py_None; __Pyx_INCREF(Py_None);

  /* "bzrlib/_simple_set_pyx.pyx":65
 *     cdef long other_hash
 * 
 *     if this == other:             # <<<<<<<<<<<<<<
 *         return 1
 *     other_hash = PyObject_Hash(other)
 */
  __pyx_t_1 = (__pyx_v_this == __pyx_v_other);
  if (__pyx_t_1) {

    /* "bzrlib/_simple_set_pyx.pyx":66
 * 
 *     if this == other:
 *         return 1             # <<<<<<<<<<<<<<
 *     other_hash = PyObject_Hash(other)
 *     if other_hash != this_hash:
 */
    __pyx_r = 1;
    goto __pyx_L0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "bzrlib/_simple_set_pyx.pyx":67
 *     if this == other:
 *         return 1
 *     other_hash = PyObject_Hash(other)             # <<<<<<<<<<<<<<
 *     if other_hash != this_hash:
 *         return 0
 */
  __pyx_t_2 = PyObject_Hash(__pyx_v_other); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 67; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_other_hash = __pyx_t_2;

  /* "bzrlib/_simple_set_pyx.pyx":68
 *         return 1
 *     other_hash = PyObject_Hash(other)
 *     if other_hash != this_hash:             # <<<<<<<<<<<<<<
 *         return 0
 * 
 */
  __pyx_t_1 = (__pyx_v_other_hash != __pyx_v_this_hash);
  if (__pyx_t_1) {

    /* "bzrlib/_simple_set_pyx.pyx":69
 *     other_hash = PyObject_Hash(other)
 *     if other_hash != this_hash:
 *         return 0             # <<<<<<<<<<<<<<
 * 
 *     # This implements a subset of the PyObject_RichCompareBool functionality.
 */
    __pyx_r = 0;
    goto __pyx_L0;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "bzrlib/_simple_set_pyx.pyx":78
 *     #      equal. (It doesn't try to cast them both to some intermediate form
 *     #      that would compare equal.)
 *     res = Py_TYPE(this).tp_richcompare(this, other, Py_EQ)             # <<<<<<<<<<<<<<
 *     if res is _NotImplemented:
 *         res = Py_TYPE(other).tp_richcompare(other, this, Py_EQ)
 */
  __pyx_t_3 = Py_TYPE(__pyx_v_this)->tp_richcompare(__pyx_v_this, __pyx_v_other, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 78; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_v_res);
  __pyx_v_res = __pyx_t_3;
  __pyx_t_3 = 0;

  /* "bzrlib/_simple_set_pyx.pyx":79
 *     #      that would compare equal.)
 *     res = Py_TYPE(this).tp_richcompare(this, other, Py_EQ)
 *     if res is _NotImplemented:             # <<<<<<<<<<<<<<
 *         res = Py_TYPE(other).tp_richcompare(other, this, Py_EQ)
 *         if res is _NotImplemented:
 */
  __pyx_t_1 = (__pyx_v_res == __pyx_v_6bzrlib_15_simple_set_pyx__NotImplemented);
  if (__pyx_t_1) {

    /* "bzrlib/_simple_set_pyx.pyx":80
 *     res = Py_TYPE(this).tp_richcompare(this, other, Py_EQ)
 *     if res is _NotImplemented:
 *         res = Py_TYPE(other).tp_richcompare(other, this, Py_EQ)             # <<<<<<<<<<<<<<
 *         if res is _NotImplemented:
 *             return 0
 */
    __pyx_t_3 = Py_TYPE(__pyx_v_other)->tp_richcompare(__pyx_v_other, __pyx_v_this, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 80; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_v_res);
    __pyx_v_res = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "bzrlib/_simple_set_pyx.pyx":81
 *     if res is _NotImplemented:
 *         res = Py_TYPE(other).tp_richcompare(other, this, Py_EQ)
 *         if res is _NotImplemented:             # <<<<<<<<<<<<<<
 *             return 0
 *     if res:
 */
    __pyx_t_1 = (__pyx_v_res == __pyx_v_6bzrlib_15_simple_set_pyx__NotImplemented);
    if (__pyx_t_1) {

      /* "bzrlib/_simple_set_pyx.pyx":82
 *         res = Py_TYPE(other).tp_richcompare(other, this, Py_EQ)
 *         if res is _NotImplemented:
 *             return 0             # <<<<<<<<<<<<<<
 *     if res:
 *         return 1
 */
      __pyx_r = 0;
      goto __pyx_L0;
      goto __pyx_L6;
    }
    __pyx_L6:;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "bzrlib/_simple_set_pyx.pyx":83
 *         if res is _NotImplemented:
 *             return 0
 *     if res:             # <<<<<<<<<<<<<<
 *         return 1
 *     return 0
 */
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_v_res); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 83; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_1) {

    /* "bzrlib/_simple_set_pyx.pyx":84
 *             return 0
 *     if res:
 *         return 1             # <<<<<<<<<<<<<<
 *     return 0
 * 
 */
    __pyx_r = 1;
    goto __pyx_L0;
    goto __pyx_L7;
  }
  __pyx_L7:;

  /* "bzrlib/_simple_set_pyx.pyx":85
 *     if res:
 *         return 1
 *     return 0             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = 0;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx._is_equal");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_res);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":105
 *     DEF DEFAULT_SIZE=1024
 * 
 *     def __init__(self):             # <<<<<<<<<<<<<<
 *         cdef Py_ssize_t size, n_bytes
 * 
 */

static int __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  Py_ssize_t __pyx_v_size;
  Py_ssize_t __pyx_v_n_bytes;
  int __pyx_r;
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__init__");
  if (unlikely(PyTuple_GET_SIZE(__pyx_args) > 0)) {
    __Pyx_RaiseArgtupleInvalid("__init__", 1, 0, 0, PyTuple_GET_SIZE(__pyx_args)); return -1;}
  if (unlikely(__pyx_kwds) && unlikely(PyDict_Size(__pyx_kwds) > 0) && unlikely(!__Pyx_CheckKeywordStrings(__pyx_kwds, "__init__", 0))) return -1;

  /* "bzrlib/_simple_set_pyx.pyx":108
 *         cdef Py_ssize_t size, n_bytes
 * 
 *         size = DEFAULT_SIZE             # <<<<<<<<<<<<<<
 *         self._mask = size - 1
 *         self._used = 0
 */
  __pyx_v_size = 1024;

  /* "bzrlib/_simple_set_pyx.pyx":109
 * 
 *         size = DEFAULT_SIZE
 *         self._mask = size - 1             # <<<<<<<<<<<<<<
 *         self._used = 0
 *         self._fill = 0
 */
  ((struct SimpleSetObject *)__pyx_v_self)->_mask = (__pyx_v_size - 1);

  /* "bzrlib/_simple_set_pyx.pyx":110
 *         size = DEFAULT_SIZE
 *         self._mask = size - 1
 *         self._used = 0             # <<<<<<<<<<<<<<
 *         self._fill = 0
 *         n_bytes = sizeof(PyObject*) * size;
 */
  ((struct SimpleSetObject *)__pyx_v_self)->_used = 0;

  /* "bzrlib/_simple_set_pyx.pyx":111
 *         self._mask = size - 1
 *         self._used = 0
 *         self._fill = 0             # <<<<<<<<<<<<<<
 *         n_bytes = sizeof(PyObject*) * size;
 *         self._table = <PyObject **>PyMem_Malloc(n_bytes)
 */
  ((struct SimpleSetObject *)__pyx_v_self)->_fill = 0;

  /* "bzrlib/_simple_set_pyx.pyx":112
 *         self._used = 0
 *         self._fill = 0
 *         n_bytes = sizeof(PyObject*) * size;             # <<<<<<<<<<<<<<
 *         self._table = <PyObject **>PyMem_Malloc(n_bytes)
 *         if self._table == NULL:
 */
  __pyx_v_n_bytes = ((sizeof(PyObject *)) * __pyx_v_size);

  /* "bzrlib/_simple_set_pyx.pyx":113
 *         self._fill = 0
 *         n_bytes = sizeof(PyObject*) * size;
 *         self._table = <PyObject **>PyMem_Malloc(n_bytes)             # <<<<<<<<<<<<<<
 *         if self._table == NULL:
 *             raise MemoryError()
 */
  ((struct SimpleSetObject *)__pyx_v_self)->_table = ((PyObject **)PyMem_Malloc(__pyx_v_n_bytes));

  /* "bzrlib/_simple_set_pyx.pyx":114
 *         n_bytes = sizeof(PyObject*) * size;
 *         self._table = <PyObject **>PyMem_Malloc(n_bytes)
 *         if self._table == NULL:             # <<<<<<<<<<<<<<
 *             raise MemoryError()
 *         memset(self._table, 0, n_bytes)
 */
  __pyx_t_1 = (((struct SimpleSetObject *)__pyx_v_self)->_table == NULL);
  if (__pyx_t_1) {

    /* "bzrlib/_simple_set_pyx.pyx":115
 *         self._table = <PyObject **>PyMem_Malloc(n_bytes)
 *         if self._table == NULL:
 *             raise MemoryError()             # <<<<<<<<<<<<<<
 *         memset(self._table, 0, n_bytes)
 * 
 */
    PyErr_NoMemory(); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "bzrlib/_simple_set_pyx.pyx":116
 *         if self._table == NULL:
 *             raise MemoryError()
 *         memset(self._table, 0, n_bytes)             # <<<<<<<<<<<<<<
 * 
 *     def __sizeof__(self):
 */
  memset(((struct SimpleSetObject *)__pyx_v_self)->_table, 0, __pyx_v_n_bytes);

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet.__init__");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":118
 *         memset(self._table, 0, n_bytes)
 * 
 *     def __sizeof__(self):             # <<<<<<<<<<<<<<
 *         # Note: Pyrex doesn't allow sizeof(class) so we re-implement it here.
 *         # Bits are:
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_1__sizeof__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_1__sizeof__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__sizeof__");

  /* "bzrlib/_simple_set_pyx.pyx":128
 *         # better than no estimate at all
 *         # return sizeof(SimpleSet) + (self._mask + 1) * (sizeof(PyObject*))
 *         return (sizeof(PyObject) + sizeof(void*)             # <<<<<<<<<<<<<<
 *                 + 3*sizeof(Py_ssize_t) + sizeof(PyObject**)
 *                 + (self._mask + 1) * sizeof(PyObject*))
 */
  __Pyx_XDECREF(__pyx_r);

  /* "bzrlib/_simple_set_pyx.pyx":130
 *         return (sizeof(PyObject) + sizeof(void*)
 *                 + 3*sizeof(Py_ssize_t) + sizeof(PyObject**)
 *                 + (self._mask + 1) * sizeof(PyObject*))             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_t_1 = __Pyx_PyInt_FromSize_t((((((sizeof(PyObject)) + (sizeof(void *))) + (3 * (sizeof(Py_ssize_t)))) + (sizeof(PyObject **))) + ((((struct SimpleSetObject *)__pyx_v_self)->_mask + 1) * (sizeof(PyObject *))))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 130; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet.__sizeof__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":132
 *                 + (self._mask + 1) * sizeof(PyObject*))
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self._table != NULL:
 *             PyMem_Free(self._table)
 */

static void __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_2__dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_2__dealloc__(PyObject *__pyx_v_self) {
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("__dealloc__");

  /* "bzrlib/_simple_set_pyx.pyx":133
 * 
 *     def __dealloc__(self):
 *         if self._table != NULL:             # <<<<<<<<<<<<<<
 *             PyMem_Free(self._table)
 *             self._table = NULL
 */
  __pyx_t_1 = (((struct SimpleSetObject *)__pyx_v_self)->_table != NULL);
  if (__pyx_t_1) {

    /* "bzrlib/_simple_set_pyx.pyx":134
 *     def __dealloc__(self):
 *         if self._table != NULL:
 *             PyMem_Free(self._table)             # <<<<<<<<<<<<<<
 *             self._table = NULL
 * 
 */
    PyMem_Free(((struct SimpleSetObject *)__pyx_v_self)->_table);

    /* "bzrlib/_simple_set_pyx.pyx":135
 *         if self._table != NULL:
 *             PyMem_Free(self._table)
 *             self._table = NULL             # <<<<<<<<<<<<<<
 * 
 *     property used:
 */
    ((struct SimpleSetObject *)__pyx_v_self)->_table = NULL;
    goto __pyx_L5;
  }
  __pyx_L5:;

  __Pyx_RefNannyFinishContext();
}

/* "bzrlib/_simple_set_pyx.pyx":138
 * 
 *     property used:
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             return self._used
 * 
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_4used___get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_4used___get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__");

  /* "bzrlib/_simple_set_pyx.pyx":139
 *     property used:
 *         def __get__(self):
 *             return self._used             # <<<<<<<<<<<<<<
 * 
 *     property fill:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyInt_FromSsize_t(((struct SimpleSetObject *)__pyx_v_self)->_used); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 139; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet.used.__get__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":142
 * 
 *     property fill:
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             return self._fill
 * 
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_4fill___get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_4fill___get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__");

  /* "bzrlib/_simple_set_pyx.pyx":143
 *     property fill:
 *         def __get__(self):
 *             return self._fill             # <<<<<<<<<<<<<<
 * 
 *     property mask:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyInt_FromSsize_t(((struct SimpleSetObject *)__pyx_v_self)->_fill); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 143; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet.fill.__get__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":146
 * 
 *     property mask:
 *         def __get__(self):             # <<<<<<<<<<<<<<
 *             return self._mask
 * 
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_4mask___get__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_4mask___get__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("__get__");

  /* "bzrlib/_simple_set_pyx.pyx":147
 *     property mask:
 *         def __get__(self):
 *             return self._mask             # <<<<<<<<<<<<<<
 * 
 *     def _memory_size(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyInt_FromSsize_t(((struct SimpleSetObject *)__pyx_v_self)->_mask); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 147; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet.mask.__get__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":149
 *             return self._mask
 * 
 *     def _memory_size(self):             # <<<<<<<<<<<<<<
 *         """Return the number of bytes of memory consumed by this class."""
 *         return sizeof(self) + (sizeof(PyObject*)*(self._mask + 1))
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_3_memory_size(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static char __pyx_doc_6bzrlib_15_simple_set_pyx_9SimpleSet_3_memory_size[] = "Return the number of bytes of memory consumed by this class.";
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_3_memory_size(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("_memory_size");

  /* "bzrlib/_simple_set_pyx.pyx":151
 *     def _memory_size(self):
 *         """Return the number of bytes of memory consumed by this class."""
 *         return sizeof(self) + (sizeof(PyObject*)*(self._mask + 1))             # <<<<<<<<<<<<<<
 * 
 *     def __len__(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyInt_FromSize_t(((sizeof(__pyx_v_self)) + ((sizeof(PyObject *)) * (((struct SimpleSetObject *)__pyx_v_self)->_mask + 1)))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 151; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet._memory_size");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":153
 *         return sizeof(self) + (sizeof(PyObject*)*(self._mask + 1))
 * 
 *     def __len__(self):             # <<<<<<<<<<<<<<
 *         return self._used
 * 
 */

static Py_ssize_t __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_4__len__(PyObject *__pyx_v_self); /*proto*/
static Py_ssize_t __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_4__len__(PyObject *__pyx_v_self) {
  Py_ssize_t __pyx_r;
  __Pyx_RefNannySetupContext("__len__");

  /* "bzrlib/_simple_set_pyx.pyx":154
 * 
 *     def __len__(self):
 *         return self._used             # <<<<<<<<<<<<<<
 * 
 *     def _test_lookup(self, key):
 */
  __pyx_r = ((struct SimpleSetObject *)__pyx_v_self)->_used;
  goto __pyx_L0;

  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":156
 *         return self._used
 * 
 *     def _test_lookup(self, key):             # <<<<<<<<<<<<<<
 *         cdef PyObject **slot
 * 
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_5_test_lookup(PyObject *__pyx_v_self, PyObject *__pyx_v_key); /*proto*/
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_5_test_lookup(PyObject *__pyx_v_self, PyObject *__pyx_v_key) {
  PyObject **__pyx_v_slot;
  PyObject *__pyx_v_res;
  PyObject *__pyx_r = NULL;
  PyObject **__pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("_test_lookup");
  __pyx_v_res = Py_None; __Pyx_INCREF(Py_None);

  /* "bzrlib/_simple_set_pyx.pyx":159
 *         cdef PyObject **slot
 * 
 *         slot = _lookup(self, key)             # <<<<<<<<<<<<<<
 *         if slot[0] == NULL:
 *             res = '<null>'
 */
  __pyx_t_1 = __pyx_f_6bzrlib_15_simple_set_pyx__lookup(((struct SimpleSetObject *)__pyx_v_self), __pyx_v_key); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 159; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_slot = __pyx_t_1;

  /* "bzrlib/_simple_set_pyx.pyx":160
 * 
 *         slot = _lookup(self, key)
 *         if slot[0] == NULL:             # <<<<<<<<<<<<<<
 *             res = '<null>'
 *         elif slot[0] == _dummy:
 */
  __pyx_t_2 = ((__pyx_v_slot[0]) == NULL);
  if (__pyx_t_2) {

    /* "bzrlib/_simple_set_pyx.pyx":161
 *         slot = _lookup(self, key)
 *         if slot[0] == NULL:
 *             res = '<null>'             # <<<<<<<<<<<<<<
 *         elif slot[0] == _dummy:
 *             res = '<dummy>'
 */
    __Pyx_INCREF(((PyObject *)__pyx_kp_s_1));
    __Pyx_DECREF(__pyx_v_res);
    __pyx_v_res = ((PyObject *)__pyx_kp_s_1);
    goto __pyx_L5;
  }

  /* "bzrlib/_simple_set_pyx.pyx":162
 *         if slot[0] == NULL:
 *             res = '<null>'
 *         elif slot[0] == _dummy:             # <<<<<<<<<<<<<<
 *             res = '<dummy>'
 *         else:
 */
  __pyx_t_2 = ((__pyx_v_slot[0]) == __pyx_v_6bzrlib_15_simple_set_pyx__dummy);
  if (__pyx_t_2) {

    /* "bzrlib/_simple_set_pyx.pyx":163
 *             res = '<null>'
 *         elif slot[0] == _dummy:
 *             res = '<dummy>'             # <<<<<<<<<<<<<<
 *         else:
 *             res = <object>slot[0]
 */
    __Pyx_INCREF(((PyObject *)__pyx_kp_s_2));
    __Pyx_DECREF(__pyx_v_res);
    __pyx_v_res = ((PyObject *)__pyx_kp_s_2);
    goto __pyx_L5;
  }
  /*else*/ {

    /* "bzrlib/_simple_set_pyx.pyx":165
 *             res = '<dummy>'
 *         else:
 *             res = <object>slot[0]             # <<<<<<<<<<<<<<
 *         return <int>(slot - self._table), res
 * 
 */
    __pyx_t_3 = (__pyx_v_slot[0]);
    __Pyx_INCREF(((PyObject *)__pyx_t_3));
    __Pyx_DECREF(__pyx_v_res);
    __pyx_v_res = ((PyObject *)__pyx_t_3);
  }
  __pyx_L5:;

  /* "bzrlib/_simple_set_pyx.pyx":166
 *         else:
 *             res = <object>slot[0]
 *         return <int>(slot - self._table), res             # <<<<<<<<<<<<<<
 * 
 *     def __contains__(self, key):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_4 = PyInt_FromLong((__pyx_v_slot - ((struct SimpleSetObject *)__pyx_v_self)->_table)); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_t_5 = PyTuple_New(2); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 166; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_5));
  PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_t_4);
  __Pyx_GIVEREF(__pyx_t_4);
  __Pyx_INCREF(__pyx_v_res);
  PyTuple_SET_ITEM(__pyx_t_5, 1, __pyx_v_res);
  __Pyx_GIVEREF(__pyx_v_res);
  __pyx_t_4 = 0;
  __pyx_r = ((PyObject *)__pyx_t_5);
  __pyx_t_5 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet._test_lookup");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_res);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":168
 *         return <int>(slot - self._table), res
 * 
 *     def __contains__(self, key):             # <<<<<<<<<<<<<<
 *         """Is key present in this SimpleSet."""
 *         cdef PyObject **slot
 */

static int __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_6__contains__(PyObject *__pyx_v_self, PyObject *__pyx_v_key); /*proto*/
static char __pyx_doc_6bzrlib_15_simple_set_pyx_9SimpleSet_6__contains__[] = "Is key present in this SimpleSet.";
struct wrapperbase __pyx_wrapperbase_6bzrlib_15_simple_set_pyx_9SimpleSet_6__contains__;
static int __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_6__contains__(PyObject *__pyx_v_self, PyObject *__pyx_v_key) {
  PyObject **__pyx_v_slot;
  int __pyx_r;
  PyObject **__pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  __Pyx_RefNannySetupContext("__contains__");

  /* "bzrlib/_simple_set_pyx.pyx":172
 *         cdef PyObject **slot
 * 
 *         slot = _lookup(self, key)             # <<<<<<<<<<<<<<
 *         if slot[0] == NULL or slot[0] == _dummy:
 *             return False
 */
  __pyx_t_1 = __pyx_f_6bzrlib_15_simple_set_pyx__lookup(((struct SimpleSetObject *)__pyx_v_self), __pyx_v_key); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_slot = __pyx_t_1;

  /* "bzrlib/_simple_set_pyx.pyx":173
 * 
 *         slot = _lookup(self, key)
 *         if slot[0] == NULL or slot[0] == _dummy:             # <<<<<<<<<<<<<<
 *             return False
 *         return True
 */
  __pyx_t_2 = ((__pyx_v_slot[0]) == NULL);
  if (!__pyx_t_2) {
    __pyx_t_3 = ((__pyx_v_slot[0]) == __pyx_v_6bzrlib_15_simple_set_pyx__dummy);
    __pyx_t_4 = __pyx_t_3;
  } else {
    __pyx_t_4 = __pyx_t_2;
  }
  if (__pyx_t_4) {

    /* "bzrlib/_simple_set_pyx.pyx":174
 *         slot = _lookup(self, key)
 *         if slot[0] == NULL or slot[0] == _dummy:
 *             return False             # <<<<<<<<<<<<<<
 *         return True
 * 
 */
    __pyx_r = 0;
    goto __pyx_L0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "bzrlib/_simple_set_pyx.pyx":175
 *         if slot[0] == NULL or slot[0] == _dummy:
 *             return False
 *         return True             # <<<<<<<<<<<<<<
 * 
 *     cdef PyObject *_get(self, object key) except? NULL:
 */
  __pyx_r = 1;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet.__contains__");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":177
 *         return True
 * 
 *     cdef PyObject *_get(self, object key) except? NULL:             # <<<<<<<<<<<<<<
 *         """Return the object (or nothing) define at the given location."""
 *         cdef PyObject **slot
 */

static  PyObject *__pyx_f_6bzrlib_15_simple_set_pyx_9SimpleSet__get(struct SimpleSetObject *__pyx_v_self, PyObject *__pyx_v_key) {
  PyObject **__pyx_v_slot;
  PyObject *__pyx_r;
  PyObject **__pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  __Pyx_RefNannySetupContext("_get");

  /* "bzrlib/_simple_set_pyx.pyx":181
 *         cdef PyObject **slot
 * 
 *         slot = _lookup(self, key)             # <<<<<<<<<<<<<<
 *         if slot[0] == NULL or slot[0] == _dummy:
 *             return NULL
 */
  __pyx_t_1 = __pyx_f_6bzrlib_15_simple_set_pyx__lookup(__pyx_v_self, __pyx_v_key); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 181; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_slot = __pyx_t_1;

  /* "bzrlib/_simple_set_pyx.pyx":182
 * 
 *         slot = _lookup(self, key)
 *         if slot[0] == NULL or slot[0] == _dummy:             # <<<<<<<<<<<<<<
 *             return NULL
 *         return slot[0]
 */
  __pyx_t_2 = ((__pyx_v_slot[0]) == NULL);
  if (!__pyx_t_2) {
    __pyx_t_3 = ((__pyx_v_slot[0]) == __pyx_v_6bzrlib_15_simple_set_pyx__dummy);
    __pyx_t_4 = __pyx_t_3;
  } else {
    __pyx_t_4 = __pyx_t_2;
  }
  if (__pyx_t_4) {

    /* "bzrlib/_simple_set_pyx.pyx":183
 *         slot = _lookup(self, key)
 *         if slot[0] == NULL or slot[0] == _dummy:
 *             return NULL             # <<<<<<<<<<<<<<
 *         return slot[0]
 * 
 */
    __pyx_r = NULL;
    goto __pyx_L0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "bzrlib/_simple_set_pyx.pyx":184
 *         if slot[0] == NULL or slot[0] == _dummy:
 *             return NULL
 *         return slot[0]             # <<<<<<<<<<<<<<
 * 
 *     def __getitem__(self, key):
 */
  __pyx_r = (__pyx_v_slot[0]);
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet._get");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":186
 *         return slot[0]
 * 
 *     def __getitem__(self, key):             # <<<<<<<<<<<<<<
 *         """Return a stored item that is equivalent to key."""
 *         cdef PyObject *py_val
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_7__getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_key); /*proto*/
static char __pyx_doc_6bzrlib_15_simple_set_pyx_9SimpleSet_7__getitem__[] = "Return a stored item that is equivalent to key.";
struct wrapperbase __pyx_wrapperbase_6bzrlib_15_simple_set_pyx_9SimpleSet_7__getitem__;
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_7__getitem__(PyObject *__pyx_v_self, PyObject *__pyx_v_key) {
  PyObject *__pyx_v_py_val;
  PyObject *__pyx_v_val;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__getitem__");
  __pyx_v_val = Py_None; __Pyx_INCREF(Py_None);

  /* "bzrlib/_simple_set_pyx.pyx":190
 *         cdef PyObject *py_val
 * 
 *         py_val = self._get(key)             # <<<<<<<<<<<<<<
 *         if py_val == NULL:
 *             raise KeyError("Key %s is not present" % key)
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet *)((struct SimpleSetObject *)__pyx_v_self)->__pyx_vtab)->_get(((struct SimpleSetObject *)__pyx_v_self), __pyx_v_key); if (unlikely(__pyx_t_1 == NULL && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 190; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_py_val = __pyx_t_1;

  /* "bzrlib/_simple_set_pyx.pyx":191
 * 
 *         py_val = self._get(key)
 *         if py_val == NULL:             # <<<<<<<<<<<<<<
 *             raise KeyError("Key %s is not present" % key)
 *         val = <object>(py_val)
 */
  __pyx_t_2 = (__pyx_v_py_val == NULL);
  if (__pyx_t_2) {

    /* "bzrlib/_simple_set_pyx.pyx":192
 *         py_val = self._get(key)
 *         if py_val == NULL:
 *             raise KeyError("Key %s is not present" % key)             # <<<<<<<<<<<<<<
 *         val = <object>(py_val)
 *         return val
 */
    __pyx_t_3 = PyNumber_Remainder(((PyObject *)__pyx_kp_s_3), __pyx_v_key); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_4));
    PyTuple_SET_ITEM(__pyx_t_4, 0, ((PyObject *)__pyx_t_3));
    __Pyx_GIVEREF(((PyObject *)__pyx_t_3));
    __pyx_t_3 = 0;
    __pyx_t_3 = PyObject_Call(__pyx_builtin_KeyError, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "bzrlib/_simple_set_pyx.pyx":193
 *         if py_val == NULL:
 *             raise KeyError("Key %s is not present" % key)
 *         val = <object>(py_val)             # <<<<<<<<<<<<<<
 *         return val
 * 
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_py_val));
  __Pyx_DECREF(__pyx_v_val);
  __pyx_v_val = ((PyObject *)__pyx_v_py_val);

  /* "bzrlib/_simple_set_pyx.pyx":194
 *             raise KeyError("Key %s is not present" % key)
 *         val = <object>(py_val)
 *         return val             # <<<<<<<<<<<<<<
 * 
 *     cdef int _insert_clean(self, PyObject *key) except -1:
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_val);
  __pyx_r = __pyx_v_val;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet.__getitem__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_val);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":196
 *         return val
 * 
 *     cdef int _insert_clean(self, PyObject *key) except -1:             # <<<<<<<<<<<<<<
 *         """Insert a key into self.table.
 * 
 */

static  int __pyx_f_6bzrlib_15_simple_set_pyx_9SimpleSet__insert_clean(struct SimpleSetObject *__pyx_v_self, PyObject *__pyx_v_key) {
  size_t __pyx_v_i;
  size_t __pyx_v_n_lookup;
  long __pyx_v_the_hash;
  PyObject **__pyx_v_table;
  PyObject **__pyx_v_slot;
  Py_ssize_t __pyx_v_mask;
  int __pyx_r;
  long __pyx_t_1;
  size_t __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("_insert_clean");

  /* "bzrlib/_simple_set_pyx.pyx":208
 *         cdef Py_ssize_t mask
 * 
 *         mask = self._mask             # <<<<<<<<<<<<<<
 *         table = self._table
 * 
 */
  __pyx_v_mask = __pyx_v_self->_mask;

  /* "bzrlib/_simple_set_pyx.pyx":209
 * 
 *         mask = self._mask
 *         table = self._table             # <<<<<<<<<<<<<<
 * 
 *         the_hash = PyObject_Hash(key)
 */
  __pyx_v_table = __pyx_v_self->_table;

  /* "bzrlib/_simple_set_pyx.pyx":211
 *         table = self._table
 * 
 *         the_hash = PyObject_Hash(key)             # <<<<<<<<<<<<<<
 *         i = the_hash
 *         for n_lookup from 0 <= n_lookup <= <size_t>mask: # Don't loop forever
 */
  __pyx_t_1 = PyObject_Hash(__pyx_v_key); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 211; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_the_hash = __pyx_t_1;

  /* "bzrlib/_simple_set_pyx.pyx":212
 * 
 *         the_hash = PyObject_Hash(key)
 *         i = the_hash             # <<<<<<<<<<<<<<
 *         for n_lookup from 0 <= n_lookup <= <size_t>mask: # Don't loop forever
 *             slot = &table[i & mask]
 */
  __pyx_v_i = __pyx_v_the_hash;

  /* "bzrlib/_simple_set_pyx.pyx":213
 *         the_hash = PyObject_Hash(key)
 *         i = the_hash
 *         for n_lookup from 0 <= n_lookup <= <size_t>mask: # Don't loop forever             # <<<<<<<<<<<<<<
 *             slot = &table[i & mask]
 *             if slot[0] == NULL:
 */
  __pyx_t_2 = ((size_t)__pyx_v_mask);
  for (__pyx_v_n_lookup = 0; __pyx_v_n_lookup <= __pyx_t_2; __pyx_v_n_lookup++) {

    /* "bzrlib/_simple_set_pyx.pyx":214
 *         i = the_hash
 *         for n_lookup from 0 <= n_lookup <= <size_t>mask: # Don't loop forever
 *             slot = &table[i & mask]             # <<<<<<<<<<<<<<
 *             if slot[0] == NULL:
 *                 slot[0] = key
 */
    __pyx_v_slot = (&(__pyx_v_table[(__pyx_v_i & __pyx_v_mask)]));

    /* "bzrlib/_simple_set_pyx.pyx":215
 *         for n_lookup from 0 <= n_lookup <= <size_t>mask: # Don't loop forever
 *             slot = &table[i & mask]
 *             if slot[0] == NULL:             # <<<<<<<<<<<<<<
 *                 slot[0] = key
 *                 self._fill = self._fill + 1
 */
    __pyx_t_3 = ((__pyx_v_slot[0]) == NULL);
    if (__pyx_t_3) {

      /* "bzrlib/_simple_set_pyx.pyx":216
 *             slot = &table[i & mask]
 *             if slot[0] == NULL:
 *                 slot[0] = key             # <<<<<<<<<<<<<<
 *                 self._fill = self._fill + 1
 *                 self._used = self._used + 1
 */
      (__pyx_v_slot[0]) = __pyx_v_key;

      /* "bzrlib/_simple_set_pyx.pyx":217
 *             if slot[0] == NULL:
 *                 slot[0] = key
 *                 self._fill = self._fill + 1             # <<<<<<<<<<<<<<
 *                 self._used = self._used + 1
 *                 return 1
 */
      __pyx_v_self->_fill = (__pyx_v_self->_fill + 1);

      /* "bzrlib/_simple_set_pyx.pyx":218
 *                 slot[0] = key
 *                 self._fill = self._fill + 1
 *                 self._used = self._used + 1             # <<<<<<<<<<<<<<
 *                 return 1
 *             i = i + 1 + n_lookup
 */
      __pyx_v_self->_used = (__pyx_v_self->_used + 1);

      /* "bzrlib/_simple_set_pyx.pyx":219
 *                 self._fill = self._fill + 1
 *                 self._used = self._used + 1
 *                 return 1             # <<<<<<<<<<<<<<
 *             i = i + 1 + n_lookup
 *         raise RuntimeError('ran out of slots.')
 */
      __pyx_r = 1;
      goto __pyx_L0;
      goto __pyx_L5;
    }
    __pyx_L5:;

    /* "bzrlib/_simple_set_pyx.pyx":220
 *                 self._used = self._used + 1
 *                 return 1
 *             i = i + 1 + n_lookup             # <<<<<<<<<<<<<<
 *         raise RuntimeError('ran out of slots.')
 * 
 */
    __pyx_v_i = ((__pyx_v_i + 1) + __pyx_v_n_lookup);
  }

  /* "bzrlib/_simple_set_pyx.pyx":221
 *                 return 1
 *             i = i + 1 + n_lookup
 *         raise RuntimeError('ran out of slots.')             # <<<<<<<<<<<<<<
 * 
 *     def _py_resize(self, min_used):
 */
  __pyx_t_4 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_5), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_Raise(__pyx_t_4, 0, 0);
  __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet._insert_clean");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":223
 *         raise RuntimeError('ran out of slots.')
 * 
 *     def _py_resize(self, min_used):             # <<<<<<<<<<<<<<
 *         """Do not use this directly, it is only exposed for testing."""
 *         return self._resize(min_used)
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_8_py_resize(PyObject *__pyx_v_self, PyObject *__pyx_v_min_used); /*proto*/
static char __pyx_doc_6bzrlib_15_simple_set_pyx_9SimpleSet_8_py_resize[] = "Do not use this directly, it is only exposed for testing.";
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_8_py_resize(PyObject *__pyx_v_self, PyObject *__pyx_v_min_used) {
  PyObject *__pyx_r = NULL;
  Py_ssize_t __pyx_t_1;
  Py_ssize_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_RefNannySetupContext("_py_resize");

  /* "bzrlib/_simple_set_pyx.pyx":225
 *     def _py_resize(self, min_used):
 *         """Do not use this directly, it is only exposed for testing."""
 *         return self._resize(min_used)             # <<<<<<<<<<<<<<
 * 
 *     cdef Py_ssize_t _resize(self, Py_ssize_t min_used) except -1:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyIndex_AsSsize_t(__pyx_v_min_used); if (unlikely((__pyx_t_1 == (Py_ssize_t)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_2 = ((struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet *)((struct SimpleSetObject *)__pyx_v_self)->__pyx_vtab)->_resize(((struct SimpleSetObject *)__pyx_v_self), __pyx_t_1); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_3 = PyInt_FromSsize_t(__pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 225; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet._py_resize");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":227
 *         return self._resize(min_used)
 * 
 *     cdef Py_ssize_t _resize(self, Py_ssize_t min_used) except -1:             # <<<<<<<<<<<<<<
 *         """Resize the internal table.
 * 
 */

static  Py_ssize_t __pyx_f_6bzrlib_15_simple_set_pyx_9SimpleSet__resize(struct SimpleSetObject *__pyx_v_self, Py_ssize_t __pyx_v_min_used) {
  Py_ssize_t __pyx_v_new_size;
  Py_ssize_t __pyx_v_n_bytes;
  Py_ssize_t __pyx_v_remaining;
  PyObject **__pyx_v_new_table;
  PyObject **__pyx_v_old_table;
  PyObject **__pyx_v_slot;
  Py_ssize_t __pyx_r;
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  __Pyx_RefNannySetupContext("_resize");

  /* "bzrlib/_simple_set_pyx.pyx":239
 *         cdef PyObject **new_table, **old_table, **slot
 * 
 *         new_size = DEFAULT_SIZE             # <<<<<<<<<<<<<<
 *         while new_size <= min_used and new_size > 0:
 *             new_size = new_size << 1
 */
  __pyx_v_new_size = 1024;

  /* "bzrlib/_simple_set_pyx.pyx":240
 * 
 *         new_size = DEFAULT_SIZE
 *         while new_size <= min_used and new_size > 0:             # <<<<<<<<<<<<<<
 *             new_size = new_size << 1
 *         # We rolled over our signed size field
 */
  while (1) {
    __pyx_t_1 = (__pyx_v_new_size <= __pyx_v_min_used);
    if (__pyx_t_1) {
      __pyx_t_2 = (__pyx_v_new_size > 0);
      __pyx_t_3 = __pyx_t_2;
    } else {
      __pyx_t_3 = __pyx_t_1;
    }
    if (!__pyx_t_3) break;

    /* "bzrlib/_simple_set_pyx.pyx":241
 *         new_size = DEFAULT_SIZE
 *         while new_size <= min_used and new_size > 0:
 *             new_size = new_size << 1             # <<<<<<<<<<<<<<
 *         # We rolled over our signed size field
 *         if new_size <= 0:
 */
    __pyx_v_new_size = (__pyx_v_new_size << 1);
  }

  /* "bzrlib/_simple_set_pyx.pyx":243
 *             new_size = new_size << 1
 *         # We rolled over our signed size field
 *         if new_size <= 0:             # <<<<<<<<<<<<<<
 *             raise MemoryError()
 *         # Even if min_used == self._mask + 1, and we aren't changing the actual
 */
  __pyx_t_3 = (__pyx_v_new_size <= 0);
  if (__pyx_t_3) {

    /* "bzrlib/_simple_set_pyx.pyx":244
 *         # We rolled over our signed size field
 *         if new_size <= 0:
 *             raise MemoryError()             # <<<<<<<<<<<<<<
 *         # Even if min_used == self._mask + 1, and we aren't changing the actual
 *         # size, we will still run the algorithm so that dummy entries are
 */
    PyErr_NoMemory(); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "bzrlib/_simple_set_pyx.pyx":252
 *         #     raise RuntimeError('cannot shrink SimpleSet to something'
 *         #                        ' smaller than the number of used slots.')
 *         n_bytes = sizeof(PyObject*) * new_size;             # <<<<<<<<<<<<<<
 *         new_table = <PyObject **>PyMem_Malloc(n_bytes)
 *         if new_table == NULL:
 */
  __pyx_v_n_bytes = ((sizeof(PyObject *)) * __pyx_v_new_size);

  /* "bzrlib/_simple_set_pyx.pyx":253
 *         #                        ' smaller than the number of used slots.')
 *         n_bytes = sizeof(PyObject*) * new_size;
 *         new_table = <PyObject **>PyMem_Malloc(n_bytes)             # <<<<<<<<<<<<<<
 *         if new_table == NULL:
 *             raise MemoryError()
 */
  __pyx_v_new_table = ((PyObject **)PyMem_Malloc(__pyx_v_n_bytes));

  /* "bzrlib/_simple_set_pyx.pyx":254
 *         n_bytes = sizeof(PyObject*) * new_size;
 *         new_table = <PyObject **>PyMem_Malloc(n_bytes)
 *         if new_table == NULL:             # <<<<<<<<<<<<<<
 *             raise MemoryError()
 * 
 */
  __pyx_t_3 = (__pyx_v_new_table == NULL);
  if (__pyx_t_3) {

    /* "bzrlib/_simple_set_pyx.pyx":255
 *         new_table = <PyObject **>PyMem_Malloc(n_bytes)
 *         if new_table == NULL:
 *             raise MemoryError()             # <<<<<<<<<<<<<<
 * 
 *         old_table = self._table
 */
    PyErr_NoMemory(); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 255; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "bzrlib/_simple_set_pyx.pyx":257
 *             raise MemoryError()
 * 
 *         old_table = self._table             # <<<<<<<<<<<<<<
 *         self._table = new_table
 *         memset(self._table, 0, n_bytes)
 */
  __pyx_v_old_table = __pyx_v_self->_table;

  /* "bzrlib/_simple_set_pyx.pyx":258
 * 
 *         old_table = self._table
 *         self._table = new_table             # <<<<<<<<<<<<<<
 *         memset(self._table, 0, n_bytes)
 *         self._mask = new_size - 1
 */
  __pyx_v_self->_table = __pyx_v_new_table;

  /* "bzrlib/_simple_set_pyx.pyx":259
 *         old_table = self._table
 *         self._table = new_table
 *         memset(self._table, 0, n_bytes)             # <<<<<<<<<<<<<<
 *         self._mask = new_size - 1
 *         self._used = 0
 */
  memset(__pyx_v_self->_table, 0, __pyx_v_n_bytes);

  /* "bzrlib/_simple_set_pyx.pyx":260
 *         self._table = new_table
 *         memset(self._table, 0, n_bytes)
 *         self._mask = new_size - 1             # <<<<<<<<<<<<<<
 *         self._used = 0
 *         remaining = self._fill
 */
  __pyx_v_self->_mask = (__pyx_v_new_size - 1);

  /* "bzrlib/_simple_set_pyx.pyx":261
 *         memset(self._table, 0, n_bytes)
 *         self._mask = new_size - 1
 *         self._used = 0             # <<<<<<<<<<<<<<
 *         remaining = self._fill
 *         self._fill = 0
 */
  __pyx_v_self->_used = 0;

  /* "bzrlib/_simple_set_pyx.pyx":262
 *         self._mask = new_size - 1
 *         self._used = 0
 *         remaining = self._fill             # <<<<<<<<<<<<<<
 *         self._fill = 0
 * 
 */
  __pyx_v_remaining = __pyx_v_self->_fill;

  /* "bzrlib/_simple_set_pyx.pyx":263
 *         self._used = 0
 *         remaining = self._fill
 *         self._fill = 0             # <<<<<<<<<<<<<<
 * 
 *         # Moving everything to the other table is refcount neutral, so we don't
 */
  __pyx_v_self->_fill = 0;

  /* "bzrlib/_simple_set_pyx.pyx":267
 *         # Moving everything to the other table is refcount neutral, so we don't
 *         # worry about it.
 *         slot = old_table             # <<<<<<<<<<<<<<
 *         while remaining > 0:
 *             if slot[0] == NULL: # unused slot
 */
  __pyx_v_slot = __pyx_v_old_table;

  /* "bzrlib/_simple_set_pyx.pyx":268
 *         # worry about it.
 *         slot = old_table
 *         while remaining > 0:             # <<<<<<<<<<<<<<
 *             if slot[0] == NULL: # unused slot
 *                 pass
 */
  while (1) {
    __pyx_t_3 = (__pyx_v_remaining > 0);
    if (!__pyx_t_3) break;

    /* "bzrlib/_simple_set_pyx.pyx":269
 *         slot = old_table
 *         while remaining > 0:
 *             if slot[0] == NULL: # unused slot             # <<<<<<<<<<<<<<
 *                 pass
 *             elif slot[0] == _dummy: # dummy slot
 */
    __pyx_t_3 = ((__pyx_v_slot[0]) == NULL);
    if (__pyx_t_3) {
      goto __pyx_L9;
    }

    /* "bzrlib/_simple_set_pyx.pyx":271
 *             if slot[0] == NULL: # unused slot
 *                 pass
 *             elif slot[0] == _dummy: # dummy slot             # <<<<<<<<<<<<<<
 *                 remaining = remaining - 1
 *             else: # active slot
 */
    __pyx_t_3 = ((__pyx_v_slot[0]) == __pyx_v_6bzrlib_15_simple_set_pyx__dummy);
    if (__pyx_t_3) {

      /* "bzrlib/_simple_set_pyx.pyx":272
 *                 pass
 *             elif slot[0] == _dummy: # dummy slot
 *                 remaining = remaining - 1             # <<<<<<<<<<<<<<
 *             else: # active slot
 *                 remaining = remaining - 1
 */
      __pyx_v_remaining = (__pyx_v_remaining - 1);
      goto __pyx_L9;
    }
    /*else*/ {

      /* "bzrlib/_simple_set_pyx.pyx":274
 *                 remaining = remaining - 1
 *             else: # active slot
 *                 remaining = remaining - 1             # <<<<<<<<<<<<<<
 *                 self._insert_clean(slot[0])
 *             slot = slot + 1
 */
      __pyx_v_remaining = (__pyx_v_remaining - 1);

      /* "bzrlib/_simple_set_pyx.pyx":275
 *             else: # active slot
 *                 remaining = remaining - 1
 *                 self._insert_clean(slot[0])             # <<<<<<<<<<<<<<
 *             slot = slot + 1
 *         PyMem_Free(old_table)
 */
      __pyx_t_4 = ((struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet *)__pyx_v_self->__pyx_vtab)->_insert_clean(__pyx_v_self, (__pyx_v_slot[0])); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 275; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    }
    __pyx_L9:;

    /* "bzrlib/_simple_set_pyx.pyx":276
 *                 remaining = remaining - 1
 *                 self._insert_clean(slot[0])
 *             slot = slot + 1             # <<<<<<<<<<<<<<
 *         PyMem_Free(old_table)
 *         return new_size
 */
    __pyx_v_slot = (__pyx_v_slot + 1);
  }

  /* "bzrlib/_simple_set_pyx.pyx":277
 *                 self._insert_clean(slot[0])
 *             slot = slot + 1
 *         PyMem_Free(old_table)             # <<<<<<<<<<<<<<
 *         return new_size
 * 
 */
  PyMem_Free(__pyx_v_old_table);

  /* "bzrlib/_simple_set_pyx.pyx":278
 *             slot = slot + 1
 *         PyMem_Free(old_table)
 *         return new_size             # <<<<<<<<<<<<<<
 * 
 *     def add(self, key):
 */
  __pyx_r = __pyx_v_new_size;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet._resize");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":280
 *         return new_size
 * 
 *     def add(self, key):             # <<<<<<<<<<<<<<
 *         """Similar to set.add(), start tracking this key.
 * 
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_9add(PyObject *__pyx_v_self, PyObject *__pyx_v_key); /*proto*/
static char __pyx_doc_6bzrlib_15_simple_set_pyx_9SimpleSet_9add[] = "Similar to set.add(), start tracking this key.\n        \n        There is one small difference, which is that we return the object that\n        is stored at the given location. (which is closer to the\n        dict.setdefault() functionality.)\n        ";
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_9add(PyObject *__pyx_v_self, PyObject *__pyx_v_key) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("add");

  /* "bzrlib/_simple_set_pyx.pyx":287
 *         dict.setdefault() functionality.)
 *         """
 *         return self._add(key)             # <<<<<<<<<<<<<<
 * 
 *     cdef object _add(self, key):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet *)((struct SimpleSetObject *)__pyx_v_self)->__pyx_vtab)->_add(((struct SimpleSetObject *)__pyx_v_self), __pyx_v_key); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 287; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet.add");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":289
 *         return self._add(key)
 * 
 *     cdef object _add(self, key):             # <<<<<<<<<<<<<<
 *         cdef PyObject **slot, *py_key
 *         cdef int added
 */

static  PyObject *__pyx_f_6bzrlib_15_simple_set_pyx_9SimpleSet__add(struct SimpleSetObject *__pyx_v_self, PyObject *__pyx_v_key) {
  PyObject **__pyx_v_slot;
  PyObject *__pyx_v_py_key;
  int __pyx_v_added;
  PyObject *__pyx_v_retval;
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject **__pyx_t_5;
  PyObject *__pyx_t_6;
  Py_ssize_t __pyx_t_7;
  __Pyx_RefNannySetupContext("_add");
  __pyx_v_retval = Py_None; __Pyx_INCREF(Py_None);

  /* "bzrlib/_simple_set_pyx.pyx":293
 *         cdef int added
 * 
 *         py_key = <PyObject *>key             # <<<<<<<<<<<<<<
 *         if (Py_TYPE(py_key).tp_richcompare == NULL
 *             or Py_TYPE(py_key).tp_hash == NULL):
 */
  __pyx_v_py_key = ((PyObject *)__pyx_v_key);

  /* "bzrlib/_simple_set_pyx.pyx":294
 * 
 *         py_key = <PyObject *>key
 *         if (Py_TYPE(py_key).tp_richcompare == NULL             # <<<<<<<<<<<<<<
 *             or Py_TYPE(py_key).tp_hash == NULL):
 *             raise TypeError('Types added to SimpleSet must implement'
 */
  __pyx_t_1 = (Py_TYPE(__pyx_v_py_key)->tp_richcompare == NULL);
  if (!__pyx_t_1) {

    /* "bzrlib/_simple_set_pyx.pyx":295
 *         py_key = <PyObject *>key
 *         if (Py_TYPE(py_key).tp_richcompare == NULL
 *             or Py_TYPE(py_key).tp_hash == NULL):             # <<<<<<<<<<<<<<
 *             raise TypeError('Types added to SimpleSet must implement'
 *                             ' both tp_richcompare and tp_hash')
 */
    __pyx_t_2 = (Py_TYPE(__pyx_v_py_key)->tp_hash == NULL);
    __pyx_t_3 = __pyx_t_2;
  } else {
    __pyx_t_3 = __pyx_t_1;
  }
  if (__pyx_t_3) {

    /* "bzrlib/_simple_set_pyx.pyx":296
 *         if (Py_TYPE(py_key).tp_richcompare == NULL
 *             or Py_TYPE(py_key).tp_hash == NULL):
 *             raise TypeError('Types added to SimpleSet must implement'             # <<<<<<<<<<<<<<
 *                             ' both tp_richcompare and tp_hash')
 *         added = 0
 */
    __pyx_t_4 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_k_tuple_7), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_Raise(__pyx_t_4, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "bzrlib/_simple_set_pyx.pyx":298
 *             raise TypeError('Types added to SimpleSet must implement'
 *                             ' both tp_richcompare and tp_hash')
 *         added = 0             # <<<<<<<<<<<<<<
 *         # We need at least one empty slot
 *         assert self._used < self._mask
 */
  __pyx_v_added = 0;

  /* "bzrlib/_simple_set_pyx.pyx":300
 *         added = 0
 *         # We need at least one empty slot
 *         assert self._used < self._mask             # <<<<<<<<<<<<<<
 *         slot = _lookup(self, key)
 *         if (slot[0] == NULL):
 */
  #ifndef CYTHON_WITHOUT_ASSERTIONS
  if (unlikely(!(__pyx_v_self->_used < __pyx_v_self->_mask))) {
    PyErr_SetNone(PyExc_AssertionError);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 300; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  #endif

  /* "bzrlib/_simple_set_pyx.pyx":301
 *         # We need at least one empty slot
 *         assert self._used < self._mask
 *         slot = _lookup(self, key)             # <<<<<<<<<<<<<<
 *         if (slot[0] == NULL):
 *             Py_INCREF(py_key)
 */
  __pyx_t_5 = __pyx_f_6bzrlib_15_simple_set_pyx__lookup(__pyx_v_self, __pyx_v_key); if (unlikely(__pyx_t_5 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 301; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_slot = __pyx_t_5;

  /* "bzrlib/_simple_set_pyx.pyx":302
 *         assert self._used < self._mask
 *         slot = _lookup(self, key)
 *         if (slot[0] == NULL):             # <<<<<<<<<<<<<<
 *             Py_INCREF(py_key)
 *             self._fill = self._fill + 1
 */
  __pyx_t_3 = ((__pyx_v_slot[0]) == NULL);
  if (__pyx_t_3) {

    /* "bzrlib/_simple_set_pyx.pyx":303
 *         slot = _lookup(self, key)
 *         if (slot[0] == NULL):
 *             Py_INCREF(py_key)             # <<<<<<<<<<<<<<
 *             self._fill = self._fill + 1
 *             self._used = self._used + 1
 */
    Py_INCREF(__pyx_v_py_key);

    /* "bzrlib/_simple_set_pyx.pyx":304
 *         if (slot[0] == NULL):
 *             Py_INCREF(py_key)
 *             self._fill = self._fill + 1             # <<<<<<<<<<<<<<
 *             self._used = self._used + 1
 *             slot[0] = py_key
 */
    __pyx_v_self->_fill = (__pyx_v_self->_fill + 1);

    /* "bzrlib/_simple_set_pyx.pyx":305
 *             Py_INCREF(py_key)
 *             self._fill = self._fill + 1
 *             self._used = self._used + 1             # <<<<<<<<<<<<<<
 *             slot[0] = py_key
 *             added = 1
 */
    __pyx_v_self->_used = (__pyx_v_self->_used + 1);

    /* "bzrlib/_simple_set_pyx.pyx":306
 *             self._fill = self._fill + 1
 *             self._used = self._used + 1
 *             slot[0] = py_key             # <<<<<<<<<<<<<<
 *             added = 1
 *         elif (slot[0] == _dummy):
 */
    (__pyx_v_slot[0]) = __pyx_v_py_key;

    /* "bzrlib/_simple_set_pyx.pyx":307
 *             self._used = self._used + 1
 *             slot[0] = py_key
 *             added = 1             # <<<<<<<<<<<<<<
 *         elif (slot[0] == _dummy):
 *             Py_INCREF(py_key)
 */
    __pyx_v_added = 1;
    goto __pyx_L4;
  }

  /* "bzrlib/_simple_set_pyx.pyx":308
 *             slot[0] = py_key
 *             added = 1
 *         elif (slot[0] == _dummy):             # <<<<<<<<<<<<<<
 *             Py_INCREF(py_key)
 *             self._used = self._used + 1
 */
  __pyx_t_3 = ((__pyx_v_slot[0]) == __pyx_v_6bzrlib_15_simple_set_pyx__dummy);
  if (__pyx_t_3) {

    /* "bzrlib/_simple_set_pyx.pyx":309
 *             added = 1
 *         elif (slot[0] == _dummy):
 *             Py_INCREF(py_key)             # <<<<<<<<<<<<<<
 *             self._used = self._used + 1
 *             slot[0] = py_key
 */
    Py_INCREF(__pyx_v_py_key);

    /* "bzrlib/_simple_set_pyx.pyx":310
 *         elif (slot[0] == _dummy):
 *             Py_INCREF(py_key)
 *             self._used = self._used + 1             # <<<<<<<<<<<<<<
 *             slot[0] = py_key
 *             added = 1
 */
    __pyx_v_self->_used = (__pyx_v_self->_used + 1);

    /* "bzrlib/_simple_set_pyx.pyx":311
 *             Py_INCREF(py_key)
 *             self._used = self._used + 1
 *             slot[0] = py_key             # <<<<<<<<<<<<<<
 *             added = 1
 *         # No else: clause. If _lookup returns a pointer to
 */
    (__pyx_v_slot[0]) = __pyx_v_py_key;

    /* "bzrlib/_simple_set_pyx.pyx":312
 *             self._used = self._used + 1
 *             slot[0] = py_key
 *             added = 1             # <<<<<<<<<<<<<<
 *         # No else: clause. If _lookup returns a pointer to
 *         # a live object, then we already have a value at this location.
 */
    __pyx_v_added = 1;
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "bzrlib/_simple_set_pyx.pyx":315
 *         # No else: clause. If _lookup returns a pointer to
 *         # a live object, then we already have a value at this location.
 *         retval = <object>(slot[0])             # <<<<<<<<<<<<<<
 *         # PySet and PyDict use a 2-3rds full algorithm, we'll follow suit
 *         if added and (self._fill * 3) >= ((self._mask + 1) * 2):
 */
  __pyx_t_6 = (__pyx_v_slot[0]);
  __Pyx_INCREF(((PyObject *)__pyx_t_6));
  __Pyx_DECREF(__pyx_v_retval);
  __pyx_v_retval = ((PyObject *)__pyx_t_6);

  /* "bzrlib/_simple_set_pyx.pyx":317
 *         retval = <object>(slot[0])
 *         # PySet and PyDict use a 2-3rds full algorithm, we'll follow suit
 *         if added and (self._fill * 3) >= ((self._mask + 1) * 2):             # <<<<<<<<<<<<<<
 *             # However, we always work for a load factor of 2:1
 *             self._resize(self._used * 2)
 */
  if (__pyx_v_added) {
    __pyx_t_3 = ((__pyx_v_self->_fill * 3) >= ((__pyx_v_self->_mask + 1) * 2));
    __pyx_t_1 = __pyx_t_3;
  } else {
    __pyx_t_1 = __pyx_v_added;
  }
  if (__pyx_t_1) {

    /* "bzrlib/_simple_set_pyx.pyx":319
 *         if added and (self._fill * 3) >= ((self._mask + 1) * 2):
 *             # However, we always work for a load factor of 2:1
 *             self._resize(self._used * 2)             # <<<<<<<<<<<<<<
 *         # Even if we resized and ended up moving retval into a different slot,
 *         # it is still the value that is held at the slot equivalent to 'key',
 */
    __pyx_t_7 = ((struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet *)__pyx_v_self->__pyx_vtab)->_resize(__pyx_v_self, (__pyx_v_self->_used * 2)); if (unlikely(__pyx_t_7 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 319; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "bzrlib/_simple_set_pyx.pyx":323
 *         # it is still the value that is held at the slot equivalent to 'key',
 *         # so we can still return it
 *         return retval             # <<<<<<<<<<<<<<
 * 
 *     def discard(self, key):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_retval);
  __pyx_r = __pyx_v_retval;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet._add");
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_retval);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":325
 *         return retval
 * 
 *     def discard(self, key):             # <<<<<<<<<<<<<<
 *         """Remove key from the set, whether it exists or not.
 * 
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_10discard(PyObject *__pyx_v_self, PyObject *__pyx_v_key); /*proto*/
static char __pyx_doc_6bzrlib_15_simple_set_pyx_9SimpleSet_10discard[] = "Remove key from the set, whether it exists or not.\n\n        :return: False if the item did not exist, True if it did\n        ";
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_10discard(PyObject *__pyx_v_self, PyObject *__pyx_v_key) {
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("discard");

  /* "bzrlib/_simple_set_pyx.pyx":330
 *         :return: False if the item did not exist, True if it did
 *         """
 *         if self._discard(key):             # <<<<<<<<<<<<<<
 *             return True
 *         return False
 */
  __pyx_t_1 = ((struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet *)((struct SimpleSetObject *)__pyx_v_self)->__pyx_vtab)->_discard(((struct SimpleSetObject *)__pyx_v_self), __pyx_v_key); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 330; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_1) {

    /* "bzrlib/_simple_set_pyx.pyx":331
 *         """
 *         if self._discard(key):
 *             return True             # <<<<<<<<<<<<<<
 *         return False
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyBool_FromLong(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 331; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "bzrlib/_simple_set_pyx.pyx":332
 *         if self._discard(key):
 *             return True
 *         return False             # <<<<<<<<<<<<<<
 * 
 *     cdef int _discard(self, key) except -1:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_2 = __Pyx_PyBool_FromLong(0); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 332; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet.discard");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":334
 *         return False
 * 
 *     cdef int _discard(self, key) except -1:             # <<<<<<<<<<<<<<
 *         cdef PyObject **slot, *py_key
 * 
 */

static  int __pyx_f_6bzrlib_15_simple_set_pyx_9SimpleSet__discard(struct SimpleSetObject *__pyx_v_self, PyObject *__pyx_v_key) {
  PyObject **__pyx_v_slot;
  int __pyx_r;
  PyObject **__pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  Py_ssize_t __pyx_t_5;
  __Pyx_RefNannySetupContext("_discard");

  /* "bzrlib/_simple_set_pyx.pyx":337
 *         cdef PyObject **slot, *py_key
 * 
 *         slot = _lookup(self, key)             # <<<<<<<<<<<<<<
 *         if slot[0] == NULL or slot[0] == _dummy:
 *             return 0
 */
  __pyx_t_1 = __pyx_f_6bzrlib_15_simple_set_pyx__lookup(__pyx_v_self, __pyx_v_key); if (unlikely(__pyx_t_1 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 337; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_slot = __pyx_t_1;

  /* "bzrlib/_simple_set_pyx.pyx":338
 * 
 *         slot = _lookup(self, key)
 *         if slot[0] == NULL or slot[0] == _dummy:             # <<<<<<<<<<<<<<
 *             return 0
 *         self._used = self._used - 1
 */
  __pyx_t_2 = ((__pyx_v_slot[0]) == NULL);
  if (!__pyx_t_2) {
    __pyx_t_3 = ((__pyx_v_slot[0]) == __pyx_v_6bzrlib_15_simple_set_pyx__dummy);
    __pyx_t_4 = __pyx_t_3;
  } else {
    __pyx_t_4 = __pyx_t_2;
  }
  if (__pyx_t_4) {

    /* "bzrlib/_simple_set_pyx.pyx":339
 *         slot = _lookup(self, key)
 *         if slot[0] == NULL or slot[0] == _dummy:
 *             return 0             # <<<<<<<<<<<<<<
 *         self._used = self._used - 1
 *         Py_DECREF(slot[0])
 */
    __pyx_r = 0;
    goto __pyx_L0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "bzrlib/_simple_set_pyx.pyx":340
 *         if slot[0] == NULL or slot[0] == _dummy:
 *             return 0
 *         self._used = self._used - 1             # <<<<<<<<<<<<<<
 *         Py_DECREF(slot[0])
 *         slot[0] = _dummy
 */
  __pyx_v_self->_used = (__pyx_v_self->_used - 1);

  /* "bzrlib/_simple_set_pyx.pyx":341
 *             return 0
 *         self._used = self._used - 1
 *         Py_DECREF(slot[0])             # <<<<<<<<<<<<<<
 *         slot[0] = _dummy
 *         # PySet uses the heuristic: If more than 1/5 are dummies, then resize
 */
  Py_DECREF((__pyx_v_slot[0]));

  /* "bzrlib/_simple_set_pyx.pyx":342
 *         self._used = self._used - 1
 *         Py_DECREF(slot[0])
 *         slot[0] = _dummy             # <<<<<<<<<<<<<<
 *         # PySet uses the heuristic: If more than 1/5 are dummies, then resize
 *         #                           them away
 */
  (__pyx_v_slot[0]) = __pyx_v_6bzrlib_15_simple_set_pyx__dummy;

  /* "bzrlib/_simple_set_pyx.pyx":353
 *         # For now, we'll just use their algorithm, but we may want to revisit
 *         # it
 *         if ((self._fill - self._used) * 5 > self._mask):             # <<<<<<<<<<<<<<
 *             self._resize(self._used * 2)
 *         return 1
 */
  __pyx_t_4 = (((__pyx_v_self->_fill - __pyx_v_self->_used) * 5) > __pyx_v_self->_mask);
  if (__pyx_t_4) {

    /* "bzrlib/_simple_set_pyx.pyx":354
 *         # it
 *         if ((self._fill - self._used) * 5 > self._mask):
 *             self._resize(self._used * 2)             # <<<<<<<<<<<<<<
 *         return 1
 * 
 */
    __pyx_t_5 = ((struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet *)__pyx_v_self->__pyx_vtab)->_resize(__pyx_v_self, (__pyx_v_self->_used * 2)); if (unlikely(__pyx_t_5 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 354; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L4;
  }
  __pyx_L4:;

  /* "bzrlib/_simple_set_pyx.pyx":355
 *         if ((self._fill - self._used) * 5 > self._mask):
 *             self._resize(self._used * 2)
 *         return 1             # <<<<<<<<<<<<<<
 * 
 *     def __iter__(self):
 */
  __pyx_r = 1;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet._discard");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":357
 *         return 1
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return _SimpleSet_iterator(self)
 * 
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_11__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_11__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("__iter__");

  /* "bzrlib/_simple_set_pyx.pyx":358
 * 
 *     def __iter__(self):
 *         return _SimpleSet_iterator(self)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 358; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_INCREF(__pyx_v_self);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_self);
  __Pyx_GIVEREF(__pyx_v_self);
  __pyx_t_2 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_6bzrlib_15_simple_set_pyx__SimpleSet_iterator)), ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 358; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet.__iter__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":369
 *     cdef Py_ssize_t len # number of entries left
 * 
 *     def __init__(self, obj):             # <<<<<<<<<<<<<<
 *         self.set = obj
 *         self.pos = 0
 */

static int __pyx_pf_6bzrlib_15_simple_set_pyx_19_SimpleSet_iterator___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pf_6bzrlib_15_simple_set_pyx_19_SimpleSet_iterator___init__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_obj = 0;
  int __pyx_r;
  static PyObject **__pyx_pyargnames[] = {&__pyx_n_s__obj,0};
  __Pyx_RefNannySetupContext("__init__");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[1] = {0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_n_s__obj);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "__init__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_obj = values[0];
  } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_obj = PyTuple_GET_ITEM(__pyx_args, 0);
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__init__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("bzrlib._simple_set_pyx._SimpleSet_iterator.__init__");
  __Pyx_RefNannyFinishContext();
  return -1;
  __pyx_L4_argument_unpacking_done:;

  /* "bzrlib/_simple_set_pyx.pyx":370
 * 
 *     def __init__(self, obj):
 *         self.set = obj             # <<<<<<<<<<<<<<
 *         self.pos = 0
 *         self._used = self.set._used
 */
  if (!(likely(((__pyx_v_obj) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_obj, __pyx_ptype_6bzrlib_15_simple_set_pyx_SimpleSet))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 370; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_INCREF(__pyx_v_obj);
  __Pyx_GIVEREF(__pyx_v_obj);
  __Pyx_GOTREF(((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->set);
  __Pyx_DECREF(((PyObject *)((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->set));
  ((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->set = ((struct SimpleSetObject *)__pyx_v_obj);

  /* "bzrlib/_simple_set_pyx.pyx":371
 *     def __init__(self, obj):
 *         self.set = obj
 *         self.pos = 0             # <<<<<<<<<<<<<<
 *         self._used = self.set._used
 *         self.len = self.set._used
 */
  ((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->pos = 0;

  /* "bzrlib/_simple_set_pyx.pyx":372
 *         self.set = obj
 *         self.pos = 0
 *         self._used = self.set._used             # <<<<<<<<<<<<<<
 *         self.len = self.set._used
 * 
 */
  ((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->_used = ((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->set->_used;

  /* "bzrlib/_simple_set_pyx.pyx":373
 *         self.pos = 0
 *         self._used = self.set._used
 *         self.len = self.set._used             # <<<<<<<<<<<<<<
 * 
 *     def __iter__(self):
 */
  ((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->len = ((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->set->_used;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("bzrlib._simple_set_pyx._SimpleSet_iterator.__init__");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":375
 *         self.len = self.set._used
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 * 
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_19_SimpleSet_iterator_1__iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_19_SimpleSet_iterator_1__iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_RefNannySetupContext("__iter__");

  /* "bzrlib/_simple_set_pyx.pyx":376
 * 
 *     def __iter__(self):
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     def __next__(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":378
 *         return self
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         cdef Py_ssize_t mask, i
 *         cdef PyObject *key
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_19_SimpleSet_iterator_2__next__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_19_SimpleSet_iterator_2__next__(PyObject *__pyx_v_self) {
  PyObject *__pyx_v_key;
  PyObject *__pyx_v_the_key;
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  __Pyx_RefNannySetupContext("__next__");
  __pyx_v_the_key = Py_None; __Pyx_INCREF(Py_None);

  /* "bzrlib/_simple_set_pyx.pyx":382
 *         cdef PyObject *key
 * 
 *         if self.set is None:             # <<<<<<<<<<<<<<
 *             raise StopIteration
 *         if self.set._used != self._used:
 */
  __pyx_t_1 = (((PyObject *)((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->set) == Py_None);
  if (__pyx_t_1) {

    /* "bzrlib/_simple_set_pyx.pyx":383
 * 
 *         if self.set is None:
 *             raise StopIteration             # <<<<<<<<<<<<<<
 *         if self.set._used != self._used:
 *             # Force this exception to continue to be raised
 */
    __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "bzrlib/_simple_set_pyx.pyx":384
 *         if self.set is None:
 *             raise StopIteration
 *         if self.set._used != self._used:             # <<<<<<<<<<<<<<
 *             # Force this exception to continue to be raised
 *             self._used = -1
 */
  __pyx_t_1 = (((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->set->_used != ((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->_used);
  if (__pyx_t_1) {

    /* "bzrlib/_simple_set_pyx.pyx":386
 *         if self.set._used != self._used:
 *             # Force this exception to continue to be raised
 *             self._used = -1             # <<<<<<<<<<<<<<
 *             raise RuntimeError("Set size changed during iteration")
 *         if not SimpleSet_Next(self.set, &self.pos, &key):
 */
    ((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->_used = -1;

    /* "bzrlib/_simple_set_pyx.pyx":387
 *             # Force this exception to continue to be raised
 *             self._used = -1
 *             raise RuntimeError("Set size changed during iteration")             # <<<<<<<<<<<<<<
 *         if not SimpleSet_Next(self.set, &self.pos, &key):
 *             self.set = None
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_RuntimeError, ((PyObject *)__pyx_k_tuple_9), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "bzrlib/_simple_set_pyx.pyx":388
 *             self._used = -1
 *             raise RuntimeError("Set size changed during iteration")
 *         if not SimpleSet_Next(self.set, &self.pos, &key):             # <<<<<<<<<<<<<<
 *             self.set = None
 *             raise StopIteration
 */
  __pyx_t_2 = ((PyObject *)((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->set);
  __Pyx_INCREF(__pyx_t_2);
  __pyx_t_3 = SimpleSet_Next(__pyx_t_2, (&((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->pos), (&__pyx_v_key)); if (unlikely(__pyx_t_3 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 388; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_t_1 = (!__pyx_t_3);
  if (__pyx_t_1) {

    /* "bzrlib/_simple_set_pyx.pyx":389
 *             raise RuntimeError("Set size changed during iteration")
 *         if not SimpleSet_Next(self.set, &self.pos, &key):
 *             self.set = None             # <<<<<<<<<<<<<<
 *             raise StopIteration
 *         # we found something
 */
    __Pyx_INCREF(Py_None);
    __Pyx_GIVEREF(Py_None);
    __Pyx_GOTREF(((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->set);
    __Pyx_DECREF(((PyObject *)((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->set));
    ((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->set = ((struct SimpleSetObject *)Py_None);

    /* "bzrlib/_simple_set_pyx.pyx":390
 *         if not SimpleSet_Next(self.set, &self.pos, &key):
 *             self.set = None
 *             raise StopIteration             # <<<<<<<<<<<<<<
 *         # we found something
 *         the_key = <object>key # INCREF
 */
    __Pyx_Raise(__pyx_builtin_StopIteration, 0, 0);
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 390; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L7;
  }
  __pyx_L7:;

  /* "bzrlib/_simple_set_pyx.pyx":392
 *             raise StopIteration
 *         # we found something
 *         the_key = <object>key # INCREF             # <<<<<<<<<<<<<<
 *         self.len = self.len - 1
 *         return the_key
 */
  __Pyx_INCREF(((PyObject *)__pyx_v_key));
  __Pyx_DECREF(__pyx_v_the_key);
  __pyx_v_the_key = ((PyObject *)__pyx_v_key);

  /* "bzrlib/_simple_set_pyx.pyx":393
 *         # we found something
 *         the_key = <object>key # INCREF
 *         self.len = self.len - 1             # <<<<<<<<<<<<<<
 *         return the_key
 * 
 */
  ((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->len = (((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->len - 1);

  /* "bzrlib/_simple_set_pyx.pyx":394
 *         the_key = <object>key # INCREF
 *         self.len = self.len - 1
 *         return the_key             # <<<<<<<<<<<<<<
 * 
 *     def __length_hint__(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_the_key);
  __pyx_r = __pyx_v_the_key;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx._SimpleSet_iterator.__next__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_the_key);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":396
 *         return the_key
 * 
 *     def __length_hint__(self):             # <<<<<<<<<<<<<<
 *         if self.set is not None and self._used == self.set._used:
 *             return self.len
 */

static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_19_SimpleSet_iterator_3__length_hint__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused); /*proto*/
static PyObject *__pyx_pf_6bzrlib_15_simple_set_pyx_19_SimpleSet_iterator_3__length_hint__(PyObject *__pyx_v_self, CYTHON_UNUSED PyObject *unused) {
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  int __pyx_t_2;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_RefNannySetupContext("__length_hint__");

  /* "bzrlib/_simple_set_pyx.pyx":397
 * 
 *     def __length_hint__(self):
 *         if self.set is not None and self._used == self.set._used:             # <<<<<<<<<<<<<<
 *             return self.len
 *         return 0
 */
  __pyx_t_1 = (((PyObject *)((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->set) != Py_None);
  if (__pyx_t_1) {
    __pyx_t_2 = (((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->_used == ((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->set->_used);
    __pyx_t_3 = __pyx_t_2;
  } else {
    __pyx_t_3 = __pyx_t_1;
  }
  if (__pyx_t_3) {

    /* "bzrlib/_simple_set_pyx.pyx":398
 *     def __length_hint__(self):
 *         if self.set is not None and self._used == self.set._used:
 *             return self.len             # <<<<<<<<<<<<<<
 *         return 0
 * 
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = PyInt_FromSsize_t(((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)__pyx_v_self)->len); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 398; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "bzrlib/_simple_set_pyx.pyx":399
 *         if self.set is not None and self._used == self.set._used:
 *             return self.len
 *         return 0             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_int_0);
  __pyx_r = __pyx_int_0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx._SimpleSet_iterator.__length_hint__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":403
 * 
 * 
 * cdef api SimpleSet SimpleSet_New():             # <<<<<<<<<<<<<<
 *     """Create a new SimpleSet object."""
 *     return SimpleSet()
 */

static  struct SimpleSetObject *SimpleSet_New(void) {
  struct SimpleSetObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("SimpleSet_New");

  /* "bzrlib/_simple_set_pyx.pyx":405
 * cdef api SimpleSet SimpleSet_New():
 *     """Create a new SimpleSet object."""
 *     return SimpleSet()             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __pyx_t_1 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_6bzrlib_15_simple_set_pyx_SimpleSet)), ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = ((struct SimpleSetObject *)__pyx_t_1);
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = ((struct SimpleSetObject *)Py_None); __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet_New");
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":408
 * 
 * 
 * cdef SimpleSet _check_self(object self):             # <<<<<<<<<<<<<<
 *     """Check that the parameter is not None.
 * 
 */

static  struct SimpleSetObject *__pyx_f_6bzrlib_15_simple_set_pyx__check_self(PyObject *__pyx_v_self) {
  struct SimpleSetObject *__pyx_v_true_self;
  struct SimpleSetObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("_check_self");
  __pyx_v_true_self = ((struct SimpleSetObject *)Py_None); __Pyx_INCREF(Py_None);

  /* "bzrlib/_simple_set_pyx.pyx":417
 *     """
 *     cdef SimpleSet true_self
 *     if self is None:             # <<<<<<<<<<<<<<
 *         raise TypeError('self must not be None')
 *     true_self = self
 */
  __pyx_t_1 = (__pyx_v_self == Py_None);
  if (__pyx_t_1) {

    /* "bzrlib/_simple_set_pyx.pyx":418
 *     cdef SimpleSet true_self
 *     if self is None:
 *         raise TypeError('self must not be None')             # <<<<<<<<<<<<<<
 *     true_self = self
 *     return true_self
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_k_tuple_11), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 418; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 418; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "bzrlib/_simple_set_pyx.pyx":419
 *     if self is None:
 *         raise TypeError('self must not be None')
 *     true_self = self             # <<<<<<<<<<<<<<
 *     return true_self
 * 
 */
  if (!(likely(((__pyx_v_self) == Py_None) || likely(__Pyx_TypeTest(__pyx_v_self, __pyx_ptype_6bzrlib_15_simple_set_pyx_SimpleSet))))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_INCREF(__pyx_v_self);
  __Pyx_DECREF(((PyObject *)__pyx_v_true_self));
  __pyx_v_true_self = ((struct SimpleSetObject *)__pyx_v_self);

  /* "bzrlib/_simple_set_pyx.pyx":420
 *         raise TypeError('self must not be None')
 *     true_self = self
 *     return true_self             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(((PyObject *)__pyx_r));
  __Pyx_INCREF(((PyObject *)__pyx_v_true_self));
  __pyx_r = __pyx_v_true_self;
  goto __pyx_L0;

  __pyx_r = ((struct SimpleSetObject *)Py_None); __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx._check_self");
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_DECREF((PyObject *)__pyx_v_true_self);
  __Pyx_XGIVEREF((PyObject *)__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":423
 * 
 * 
 * cdef PyObject **_lookup(SimpleSet self, object key) except NULL:             # <<<<<<<<<<<<<<
 *     """Find the slot where 'key' would fit.
 * 
 */

static  PyObject **__pyx_f_6bzrlib_15_simple_set_pyx__lookup(struct SimpleSetObject *__pyx_v_self, PyObject *__pyx_v_key) {
  size_t __pyx_v_i;
  size_t __pyx_v_n_lookup;
  Py_ssize_t __pyx_v_mask;
  long __pyx_v_key_hash;
  PyObject **__pyx_v_table;
  PyObject **__pyx_v_slot;
  PyObject *__pyx_v_cur;
  PyObject **__pyx_v_free_slot;
  PyObject *__pyx_v_py_key;
  PyObject **__pyx_r;
  long __pyx_t_1;
  size_t __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_RefNannySetupContext("_lookup");

  /* "bzrlib/_simple_set_pyx.pyx":464
 *     cdef PyObject **table, **slot, *cur, **free_slot, *py_key
 * 
 *     py_key = <PyObject *>key             # <<<<<<<<<<<<<<
 *     # Note: avoid using hash(obj) because of a bug w/ pyrex 0.9.8.5 and 64-bit
 *     #       (it treats hash() as returning an 'int' rather than a 'long')
 */
  __pyx_v_py_key = ((PyObject *)__pyx_v_key);

  /* "bzrlib/_simple_set_pyx.pyx":467
 *     # Note: avoid using hash(obj) because of a bug w/ pyrex 0.9.8.5 and 64-bit
 *     #       (it treats hash() as returning an 'int' rather than a 'long')
 *     key_hash = PyObject_Hash(py_key)             # <<<<<<<<<<<<<<
 *     i = <size_t>key_hash
 *     mask = self._mask
 */
  __pyx_t_1 = PyObject_Hash(__pyx_v_py_key); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 467; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_v_key_hash = __pyx_t_1;

  /* "bzrlib/_simple_set_pyx.pyx":468
 *     #       (it treats hash() as returning an 'int' rather than a 'long')
 *     key_hash = PyObject_Hash(py_key)
 *     i = <size_t>key_hash             # <<<<<<<<<<<<<<
 *     mask = self._mask
 *     table = self._table
 */
  __pyx_v_i = ((size_t)__pyx_v_key_hash);

  /* "bzrlib/_simple_set_pyx.pyx":469
 *     key_hash = PyObject_Hash(py_key)
 *     i = <size_t>key_hash
 *     mask = self._mask             # <<<<<<<<<<<<<<
 *     table = self._table
 *     free_slot = NULL
 */
  __pyx_v_mask = __pyx_v_self->_mask;

  /* "bzrlib/_simple_set_pyx.pyx":470
 *     i = <size_t>key_hash
 *     mask = self._mask
 *     table = self._table             # <<<<<<<<<<<<<<
 *     free_slot = NULL
 *     for n_lookup from 0 <= n_lookup <= <size_t>mask: # Don't loop forever
 */
  __pyx_v_table = __pyx_v_self->_table;

  /* "bzrlib/_simple_set_pyx.pyx":471
 *     mask = self._mask
 *     table = self._table
 *     free_slot = NULL             # <<<<<<<<<<<<<<
 *     for n_lookup from 0 <= n_lookup <= <size_t>mask: # Don't loop forever
 *         slot = &table[i & mask]
 */
  __pyx_v_free_slot = NULL;

  /* "bzrlib/_simple_set_pyx.pyx":472
 *     table = self._table
 *     free_slot = NULL
 *     for n_lookup from 0 <= n_lookup <= <size_t>mask: # Don't loop forever             # <<<<<<<<<<<<<<
 *         slot = &table[i & mask]
 *         cur = slot[0]
 */
  __pyx_t_2 = ((size_t)__pyx_v_mask);
  for (__pyx_v_n_lookup = 0; __pyx_v_n_lookup <= __pyx_t_2; __pyx_v_n_lookup++) {

    /* "bzrlib/_simple_set_pyx.pyx":473
 *     free_slot = NULL
 *     for n_lookup from 0 <= n_lookup <= <size_t>mask: # Don't loop forever
 *         slot = &table[i & mask]             # <<<<<<<<<<<<<<
 *         cur = slot[0]
 *         if cur == NULL:
 */
    __pyx_v_slot = (&(__pyx_v_table[(__pyx_v_i & __pyx_v_mask)]));

    /* "bzrlib/_simple_set_pyx.pyx":474
 *     for n_lookup from 0 <= n_lookup <= <size_t>mask: # Don't loop forever
 *         slot = &table[i & mask]
 *         cur = slot[0]             # <<<<<<<<<<<<<<
 *         if cur == NULL:
 *             # Found a blank spot
 */
    __pyx_v_cur = (__pyx_v_slot[0]);

    /* "bzrlib/_simple_set_pyx.pyx":475
 *         slot = &table[i & mask]
 *         cur = slot[0]
 *         if cur == NULL:             # <<<<<<<<<<<<<<
 *             # Found a blank spot
 *             if free_slot != NULL:
 */
    __pyx_t_3 = (__pyx_v_cur == NULL);
    if (__pyx_t_3) {

      /* "bzrlib/_simple_set_pyx.pyx":477
 *         if cur == NULL:
 *             # Found a blank spot
 *             if free_slot != NULL:             # <<<<<<<<<<<<<<
 *                 # Did we find an earlier _dummy entry?
 *                 return free_slot
 */
      __pyx_t_3 = (__pyx_v_free_slot != NULL);
      if (__pyx_t_3) {

        /* "bzrlib/_simple_set_pyx.pyx":479
 *             if free_slot != NULL:
 *                 # Did we find an earlier _dummy entry?
 *                 return free_slot             # <<<<<<<<<<<<<<
 *             else:
 *                 return slot
 */
        __pyx_r = __pyx_v_free_slot;
        goto __pyx_L0;
        goto __pyx_L6;
      }
      /*else*/ {

        /* "bzrlib/_simple_set_pyx.pyx":481
 *                 return free_slot
 *             else:
 *                 return slot             # <<<<<<<<<<<<<<
 *         if cur == py_key:
 *             # Found an exact pointer to the key
 */
        __pyx_r = __pyx_v_slot;
        goto __pyx_L0;
      }
      __pyx_L6:;
      goto __pyx_L5;
    }
    __pyx_L5:;

    /* "bzrlib/_simple_set_pyx.pyx":482
 *             else:
 *                 return slot
 *         if cur == py_key:             # <<<<<<<<<<<<<<
 *             # Found an exact pointer to the key
 *             return slot
 */
    __pyx_t_3 = (__pyx_v_cur == __pyx_v_py_key);
    if (__pyx_t_3) {

      /* "bzrlib/_simple_set_pyx.pyx":484
 *         if cur == py_key:
 *             # Found an exact pointer to the key
 *             return slot             # <<<<<<<<<<<<<<
 *         if cur == _dummy:
 *             if free_slot == NULL:
 */
      __pyx_r = __pyx_v_slot;
      goto __pyx_L0;
      goto __pyx_L7;
    }
    __pyx_L7:;

    /* "bzrlib/_simple_set_pyx.pyx":485
 *             # Found an exact pointer to the key
 *             return slot
 *         if cur == _dummy:             # <<<<<<<<<<<<<<
 *             if free_slot == NULL:
 *                 free_slot = slot
 */
    __pyx_t_3 = (__pyx_v_cur == __pyx_v_6bzrlib_15_simple_set_pyx__dummy);
    if (__pyx_t_3) {

      /* "bzrlib/_simple_set_pyx.pyx":486
 *             return slot
 *         if cur == _dummy:
 *             if free_slot == NULL:             # <<<<<<<<<<<<<<
 *                 free_slot = slot
 *         elif _is_equal(py_key, key_hash, cur):
 */
      __pyx_t_3 = (__pyx_v_free_slot == NULL);
      if (__pyx_t_3) {

        /* "bzrlib/_simple_set_pyx.pyx":487
 *         if cur == _dummy:
 *             if free_slot == NULL:
 *                 free_slot = slot             # <<<<<<<<<<<<<<
 *         elif _is_equal(py_key, key_hash, cur):
 *             # Both py_key and cur belong in this slot, return it
 */
        __pyx_v_free_slot = __pyx_v_slot;
        goto __pyx_L9;
      }
      __pyx_L9:;
      goto __pyx_L8;
    }

    /* "bzrlib/_simple_set_pyx.pyx":488
 *             if free_slot == NULL:
 *                 free_slot = slot
 *         elif _is_equal(py_key, key_hash, cur):             # <<<<<<<<<<<<<<
 *             # Both py_key and cur belong in this slot, return it
 *             return slot
 */
    __pyx_t_4 = __pyx_f_6bzrlib_15_simple_set_pyx__is_equal(__pyx_v_py_key, __pyx_v_key_hash, __pyx_v_cur); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 488; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (__pyx_t_4) {

      /* "bzrlib/_simple_set_pyx.pyx":490
 *         elif _is_equal(py_key, key_hash, cur):
 *             # Both py_key and cur belong in this slot, return it
 *             return slot             # <<<<<<<<<<<<<<
 *         i = i + 1 + n_lookup
 *     raise AssertionError('should never get here')
 */
      __pyx_r = __pyx_v_slot;
      goto __pyx_L0;
      goto __pyx_L8;
    }
    __pyx_L8:;

    /* "bzrlib/_simple_set_pyx.pyx":491
 *             # Both py_key and cur belong in this slot, return it
 *             return slot
 *         i = i + 1 + n_lookup             # <<<<<<<<<<<<<<
 *     raise AssertionError('should never get here')
 * 
 */
    __pyx_v_i = ((__pyx_v_i + 1) + __pyx_v_n_lookup);
  }

  /* "bzrlib/_simple_set_pyx.pyx":492
 *             return slot
 *         i = i + 1 + n_lookup
 *     raise AssertionError('should never get here')             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_5 = PyObject_Call(__pyx_builtin_AssertionError, ((PyObject *)__pyx_k_tuple_13), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_5);
  __Pyx_Raise(__pyx_t_5, 0, 0);
  __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx._lookup");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":495
 * 
 * 
 * cdef api PyObject **_SimpleSet_Lookup(object self, object key) except NULL:             # <<<<<<<<<<<<<<
 *     """Find the slot where 'key' would fit.
 * 
 */

static  PyObject **_SimpleSet_Lookup(PyObject *__pyx_v_self, PyObject *__pyx_v_key) {
  PyObject **__pyx_r;
  PyObject *__pyx_t_1 = NULL;
  PyObject **__pyx_t_2;
  __Pyx_RefNannySetupContext("_SimpleSet_Lookup");

  /* "bzrlib/_simple_set_pyx.pyx":507
 *         should never be NULL, but may reference a NULL (PyObject*)
 *     """
 *     return _lookup(_check_self(self), key)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = ((PyObject *)__pyx_f_6bzrlib_15_simple_set_pyx__check_self(__pyx_v_self)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 507; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = __pyx_f_6bzrlib_15_simple_set_pyx__lookup(((struct SimpleSetObject *)__pyx_t_1), __pyx_v_key); if (unlikely(__pyx_t_2 == NULL)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 507; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx._SimpleSet_Lookup");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":510
 * 
 * 
 * cdef api object SimpleSet_Add(object self, object key):             # <<<<<<<<<<<<<<
 *     """Add a key to the SimpleSet (set).
 * 
 */

static  PyObject *SimpleSet_Add(PyObject *__pyx_v_self, PyObject *__pyx_v_key) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_RefNannySetupContext("SimpleSet_Add");

  /* "bzrlib/_simple_set_pyx.pyx":520
 *         (consider dict.setdefault(key, key))
 *     """
 *     return _check_self(self)._add(key)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = ((PyObject *)__pyx_f_6bzrlib_15_simple_set_pyx__check_self(__pyx_v_self)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 520; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = ((struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet *)((struct SimpleSetObject *)__pyx_t_1)->__pyx_vtab)->_add(((struct SimpleSetObject *)__pyx_t_1), __pyx_v_key); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 520; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet_Add");
  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":523
 * 
 * 
 * cdef api int SimpleSet_Contains(object self, object key) except -1:             # <<<<<<<<<<<<<<
 *     """Is key present in self?"""
 *     return (key in _check_self(self))
 */

static  int SimpleSet_Contains(PyObject *__pyx_v_self, PyObject *__pyx_v_key) {
  int __pyx_r;
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("SimpleSet_Contains");

  /* "bzrlib/_simple_set_pyx.pyx":525
 * cdef api int SimpleSet_Contains(object self, object key) except -1:
 *     """Is key present in self?"""
 *     return (key in _check_self(self))             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = ((PyObject *)__pyx_f_6bzrlib_15_simple_set_pyx__check_self(__pyx_v_self)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = ((PySequence_Contains(__pyx_t_1, __pyx_v_key))); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet_Contains");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":528
 * 
 * 
 * cdef api int SimpleSet_Discard(object self, object key) except -1:             # <<<<<<<<<<<<<<
 *     """Remove the object referenced at location 'key'.
 * 
 */

static  int SimpleSet_Discard(PyObject *__pyx_v_self, PyObject *__pyx_v_key) {
  int __pyx_r;
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  __Pyx_RefNannySetupContext("SimpleSet_Discard");

  /* "bzrlib/_simple_set_pyx.pyx":536
 *         error.
 *     """
 *     return _check_self(self)._discard(key)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = ((PyObject *)__pyx_f_6bzrlib_15_simple_set_pyx__check_self(__pyx_v_self)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = ((struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet *)((struct SimpleSetObject *)__pyx_t_1)->__pyx_vtab)->_discard(((struct SimpleSetObject *)__pyx_t_1), __pyx_v_key); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 536; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet_Discard");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":539
 * 
 * 
 * cdef api PyObject *SimpleSet_Get(SimpleSet self, object key) except? NULL:             # <<<<<<<<<<<<<<
 *     """Get a pointer to the object present at location 'key'.
 * 
 */

static  PyObject *SimpleSet_Get(struct SimpleSetObject *__pyx_v_self, PyObject *__pyx_v_key) {
  PyObject *__pyx_r;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2;
  __Pyx_RefNannySetupContext("SimpleSet_Get");

  /* "bzrlib/_simple_set_pyx.pyx":549
 *     :return: The object present at that location
 *     """
 *     return _check_self(self)._get(key)             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = ((PyObject *)__pyx_f_6bzrlib_15_simple_set_pyx__check_self(((PyObject *)__pyx_v_self))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = ((struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet *)((struct SimpleSetObject *)__pyx_t_1)->__pyx_vtab)->_get(((struct SimpleSetObject *)__pyx_t_1), __pyx_v_key); if (unlikely(__pyx_t_2 == NULL && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 549; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet_Get");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":552
 * 
 * 
 * cdef api Py_ssize_t SimpleSet_Size(object self) except -1:             # <<<<<<<<<<<<<<
 *     """Get the number of active entries in 'self'"""
 *     return _check_self(self)._used
 */

static  Py_ssize_t SimpleSet_Size(PyObject *__pyx_v_self) {
  Py_ssize_t __pyx_r;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_RefNannySetupContext("SimpleSet_Size");

  /* "bzrlib/_simple_set_pyx.pyx":554
 * cdef api Py_ssize_t SimpleSet_Size(object self) except -1:
 *     """Get the number of active entries in 'self'"""
 *     return _check_self(self)._used             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_t_1 = ((PyObject *)__pyx_f_6bzrlib_15_simple_set_pyx__check_self(__pyx_v_self)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 554; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = ((struct SimpleSetObject *)__pyx_t_1)->_used;
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet_Size");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":557
 * 
 * 
 * cdef api int SimpleSet_Next(object self, Py_ssize_t *pos,             # <<<<<<<<<<<<<<
 *                             PyObject **key) except -1:
 *     """Walk over items in a SimpleSet.
 */

static  int SimpleSet_Next(PyObject *__pyx_v_self, Py_ssize_t *__pyx_v_pos, PyObject **__pyx_v_key) {
  Py_ssize_t __pyx_v_i;
  Py_ssize_t __pyx_v_mask;
  struct SimpleSetObject *__pyx_v_true_self;
  PyObject **__pyx_v_table;
  int __pyx_r;
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  int __pyx_t_3;
  int __pyx_t_4;
  int __pyx_t_5;
  __Pyx_RefNannySetupContext("SimpleSet_Next");
  __pyx_v_true_self = ((struct SimpleSetObject *)Py_None); __Pyx_INCREF(Py_None);

  /* "bzrlib/_simple_set_pyx.pyx":569
 *     cdef SimpleSet true_self
 *     cdef PyObject **table
 *     true_self = _check_self(self)             # <<<<<<<<<<<<<<
 *     i = pos[0]
 *     if (i < 0):
 */
  __pyx_t_1 = ((PyObject *)__pyx_f_6bzrlib_15_simple_set_pyx__check_self(__pyx_v_self)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 569; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(((PyObject *)__pyx_v_true_self));
  __pyx_v_true_self = ((struct SimpleSetObject *)__pyx_t_1);
  __pyx_t_1 = 0;

  /* "bzrlib/_simple_set_pyx.pyx":570
 *     cdef PyObject **table
 *     true_self = _check_self(self)
 *     i = pos[0]             # <<<<<<<<<<<<<<
 *     if (i < 0):
 *         return 0
 */
  __pyx_v_i = (__pyx_v_pos[0]);

  /* "bzrlib/_simple_set_pyx.pyx":571
 *     true_self = _check_self(self)
 *     i = pos[0]
 *     if (i < 0):             # <<<<<<<<<<<<<<
 *         return 0
 *     mask = true_self._mask
 */
  __pyx_t_2 = (__pyx_v_i < 0);
  if (__pyx_t_2) {

    /* "bzrlib/_simple_set_pyx.pyx":572
 *     i = pos[0]
 *     if (i < 0):
 *         return 0             # <<<<<<<<<<<<<<
 *     mask = true_self._mask
 *     table= true_self._table
 */
    __pyx_r = 0;
    goto __pyx_L0;
    goto __pyx_L3;
  }
  __pyx_L3:;

  /* "bzrlib/_simple_set_pyx.pyx":573
 *     if (i < 0):
 *         return 0
 *     mask = true_self._mask             # <<<<<<<<<<<<<<
 *     table= true_self._table
 *     while (i <= mask and (table[i] == NULL or table[i] == _dummy)):
 */
  __pyx_v_mask = __pyx_v_true_self->_mask;

  /* "bzrlib/_simple_set_pyx.pyx":574
 *         return 0
 *     mask = true_self._mask
 *     table= true_self._table             # <<<<<<<<<<<<<<
 *     while (i <= mask and (table[i] == NULL or table[i] == _dummy)):
 *         i = i + 1
 */
  __pyx_v_table = __pyx_v_true_self->_table;

  /* "bzrlib/_simple_set_pyx.pyx":575
 *     mask = true_self._mask
 *     table= true_self._table
 *     while (i <= mask and (table[i] == NULL or table[i] == _dummy)):             # <<<<<<<<<<<<<<
 *         i = i + 1
 *     pos[0] = i + 1
 */
  while (1) {
    __pyx_t_2 = (__pyx_v_i <= __pyx_v_mask);
    if (__pyx_t_2) {
      __pyx_t_3 = ((__pyx_v_table[__pyx_v_i]) == NULL);
      if (!__pyx_t_3) {
        __pyx_t_4 = ((__pyx_v_table[__pyx_v_i]) == __pyx_v_6bzrlib_15_simple_set_pyx__dummy);
        __pyx_t_5 = __pyx_t_4;
      } else {
        __pyx_t_5 = __pyx_t_3;
      }
      __pyx_t_3 = __pyx_t_5;
    } else {
      __pyx_t_3 = __pyx_t_2;
    }
    if (!__pyx_t_3) break;

    /* "bzrlib/_simple_set_pyx.pyx":576
 *     table= true_self._table
 *     while (i <= mask and (table[i] == NULL or table[i] == _dummy)):
 *         i = i + 1             # <<<<<<<<<<<<<<
 *     pos[0] = i + 1
 *     if (i > mask):
 */
    __pyx_v_i = (__pyx_v_i + 1);
  }

  /* "bzrlib/_simple_set_pyx.pyx":577
 *     while (i <= mask and (table[i] == NULL or table[i] == _dummy)):
 *         i = i + 1
 *     pos[0] = i + 1             # <<<<<<<<<<<<<<
 *     if (i > mask):
 *         return 0 # All done
 */
  (__pyx_v_pos[0]) = (__pyx_v_i + 1);

  /* "bzrlib/_simple_set_pyx.pyx":578
 *         i = i + 1
 *     pos[0] = i + 1
 *     if (i > mask):             # <<<<<<<<<<<<<<
 *         return 0 # All done
 *     if (key != NULL):
 */
  __pyx_t_3 = (__pyx_v_i > __pyx_v_mask);
  if (__pyx_t_3) {

    /* "bzrlib/_simple_set_pyx.pyx":579
 *     pos[0] = i + 1
 *     if (i > mask):
 *         return 0 # All done             # <<<<<<<<<<<<<<
 *     if (key != NULL):
 *         key[0] = table[i]
 */
    __pyx_r = 0;
    goto __pyx_L0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "bzrlib/_simple_set_pyx.pyx":580
 *     if (i > mask):
 *         return 0 # All done
 *     if (key != NULL):             # <<<<<<<<<<<<<<
 *         key[0] = table[i]
 *     return 1
 */
  __pyx_t_3 = (__pyx_v_key != NULL);
  if (__pyx_t_3) {

    /* "bzrlib/_simple_set_pyx.pyx":581
 *         return 0 # All done
 *     if (key != NULL):
 *         key[0] = table[i]             # <<<<<<<<<<<<<<
 *     return 1
 * 
 */
    (__pyx_v_key[0]) = (__pyx_v_table[__pyx_v_i]);
    goto __pyx_L7;
  }
  __pyx_L7:;

  /* "bzrlib/_simple_set_pyx.pyx":582
 *     if (key != NULL):
 *         key[0] = table[i]
 *     return 1             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_r = 1;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet_Next");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_DECREF((PyObject *)__pyx_v_true_self);
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}

/* "bzrlib/_simple_set_pyx.pyx":585
 * 
 * 
 * cdef int SimpleSet_traverse(SimpleSet self, visitproc visit,             # <<<<<<<<<<<<<<
 *                             void *arg) except -1:
 *     """This is an implementation of 'tp_traverse' that hits the whole table.
 */

static  int __pyx_f_6bzrlib_15_simple_set_pyx_SimpleSet_traverse(struct SimpleSetObject *__pyx_v_self, visitproc __pyx_v_visit, void *__pyx_v_arg) {
  Py_ssize_t __pyx_v_pos;
  PyObject *__pyx_v_next_key;
  int __pyx_v_ret;
  int __pyx_r;
  int __pyx_t_1;
  __Pyx_RefNannySetupContext("SimpleSet_traverse");

  /* "bzrlib/_simple_set_pyx.pyx":597
 *     cdef int ret
 * 
 *     pos = 0             # <<<<<<<<<<<<<<
 *     while SimpleSet_Next(self, &pos, &next_key):
 *         ret = visit(next_key, arg)
 */
  __pyx_v_pos = 0;

  /* "bzrlib/_simple_set_pyx.pyx":598
 * 
 *     pos = 0
 *     while SimpleSet_Next(self, &pos, &next_key):             # <<<<<<<<<<<<<<
 *         ret = visit(next_key, arg)
 *         if ret:
 */
  while (1) {
    __pyx_t_1 = SimpleSet_Next(((PyObject *)__pyx_v_self), (&__pyx_v_pos), (&__pyx_v_next_key)); if (unlikely(__pyx_t_1 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (!__pyx_t_1) break;

    /* "bzrlib/_simple_set_pyx.pyx":599
 *     pos = 0
 *     while SimpleSet_Next(self, &pos, &next_key):
 *         ret = visit(next_key, arg)             # <<<<<<<<<<<<<<
 *         if ret:
 *             return ret
 */
    __pyx_v_ret = __pyx_v_visit(__pyx_v_next_key, __pyx_v_arg);

    /* "bzrlib/_simple_set_pyx.pyx":600
 *     while SimpleSet_Next(self, &pos, &next_key):
 *         ret = visit(next_key, arg)
 *         if ret:             # <<<<<<<<<<<<<<
 *             return ret
 *     return 0
 */
    if (__pyx_v_ret) {

      /* "bzrlib/_simple_set_pyx.pyx":601
 *         ret = visit(next_key, arg)
 *         if ret:
 *             return ret             # <<<<<<<<<<<<<<
 *     return 0
 * 
 */
      __pyx_r = __pyx_v_ret;
      goto __pyx_L0;
      goto __pyx_L5;
    }
    __pyx_L5:;
  }

  /* "bzrlib/_simple_set_pyx.pyx":602
 *         if ret:
 *             return ret
 *     return 0             # <<<<<<<<<<<<<<
 * 
 * # It is a little bit ugly to do this, but it works, and means that Meliae can
 */
  __pyx_r = 0;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("bzrlib._simple_set_pyx.SimpleSet_traverse");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  return __pyx_r;
}
static struct __pyx_vtabstruct_6bzrlib_15_simple_set_pyx_SimpleSet __pyx_vtable_6bzrlib_15_simple_set_pyx_SimpleSet;

static PyObject *__pyx_tp_new_6bzrlib_15_simple_set_pyx_SimpleSet(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct SimpleSetObject *p;
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (!o) return 0;
  p = ((struct SimpleSetObject *)o);
  p->__pyx_vtab = __pyx_vtabptr_6bzrlib_15_simple_set_pyx_SimpleSet;
  return o;
}

static void __pyx_tp_dealloc_6bzrlib_15_simple_set_pyx_SimpleSet(PyObject *o) {
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_2__dealloc__(o);
    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  (*Py_TYPE(o)->tp_free)(o);
}
static PyObject *__pyx_sq_item_6bzrlib_15_simple_set_pyx_SimpleSet(PyObject *o, Py_ssize_t i) {
  PyObject *r;
  PyObject *x = PyInt_FromSsize_t(i); if(!x) return 0;
  r = Py_TYPE(o)->tp_as_mapping->mp_subscript(o, x);
  Py_DECREF(x);
  return r;
}

static PyObject *__pyx_getprop_6bzrlib_15_simple_set_pyx_9SimpleSet_used(PyObject *o, void *x) {
  return __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_4used___get__(o);
}

static PyObject *__pyx_getprop_6bzrlib_15_simple_set_pyx_9SimpleSet_fill(PyObject *o, void *x) {
  return __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_4fill___get__(o);
}

static PyObject *__pyx_getprop_6bzrlib_15_simple_set_pyx_9SimpleSet_mask(PyObject *o, void *x) {
  return __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_4mask___get__(o);
}

static PyMethodDef __pyx_methods_6bzrlib_15_simple_set_pyx_SimpleSet[] = {
  {__Pyx_NAMESTR("__sizeof__"), (PyCFunction)__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_1__sizeof__, METH_NOARGS, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("_memory_size"), (PyCFunction)__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_3_memory_size, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_6bzrlib_15_simple_set_pyx_9SimpleSet_3_memory_size)},
  {__Pyx_NAMESTR("_test_lookup"), (PyCFunction)__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_5_test_lookup, METH_O, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("_py_resize"), (PyCFunction)__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_8_py_resize, METH_O, __Pyx_DOCSTR(__pyx_doc_6bzrlib_15_simple_set_pyx_9SimpleSet_8_py_resize)},
  {__Pyx_NAMESTR("add"), (PyCFunction)__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_9add, METH_O, __Pyx_DOCSTR(__pyx_doc_6bzrlib_15_simple_set_pyx_9SimpleSet_9add)},
  {__Pyx_NAMESTR("discard"), (PyCFunction)__pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_10discard, METH_O, __Pyx_DOCSTR(__pyx_doc_6bzrlib_15_simple_set_pyx_9SimpleSet_10discard)},
  {0, 0, 0, 0}
};

static struct PyGetSetDef __pyx_getsets_6bzrlib_15_simple_set_pyx_SimpleSet[] = {
  {(char *)"used", __pyx_getprop_6bzrlib_15_simple_set_pyx_9SimpleSet_used, 0, 0, 0},
  {(char *)"fill", __pyx_getprop_6bzrlib_15_simple_set_pyx_9SimpleSet_fill, 0, 0, 0},
  {(char *)"mask", __pyx_getprop_6bzrlib_15_simple_set_pyx_9SimpleSet_mask, 0, 0, 0},
  {0, 0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_SimpleSet = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_divide*/
  #endif
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_coerce*/
  #endif
  0, /*nb_int*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_long*/
  #else
  0, /*reserved*/
  #endif
  0, /*nb_float*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_oct*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*nb_hex*/
  #endif
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_inplace_divide*/
  #endif
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if PY_VERSION_HEX >= 0x02050000
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence_SimpleSet = {
  __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_4__len__, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  __pyx_sq_item_6bzrlib_15_simple_set_pyx_SimpleSet, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_6__contains__, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_SimpleSet = {
  __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_4__len__, /*mp_length*/
  __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_7__getitem__, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer_SimpleSet = {
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getreadbuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getwritebuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getsegcount*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getcharbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_getbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_releasebuffer*/
  #endif
};

DL_EXPORT(PyTypeObject) SimpleSet_Type = {
  PyVarObject_HEAD_INIT(0, 0)
  __Pyx_NAMESTR("bzrlib._simple_set_pyx.SimpleSet"), /*tp_name*/
  sizeof(struct SimpleSetObject), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_6bzrlib_15_simple_set_pyx_SimpleSet, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  &__pyx_tp_as_number_SimpleSet, /*tp_as_number*/
  &__pyx_tp_as_sequence_SimpleSet, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_SimpleSet, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer_SimpleSet, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE, /*tp_flags*/
  __Pyx_DOCSTR("This class can be used to track canonical forms for objects.\n\n    It is similar in function to the interned dictionary that is used by\n    strings. However:\n\n      1) It assumes that hash(obj) is cheap, so does not need to inline a copy\n         of it\n      2) It only stores one reference to the object, rather than 2 (key vs\n         key:value)\n\n    As such, it uses 1/3rd the amount of memory to store a pointer to the\n    interned object.\n    "), /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet_11__iter__, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_6bzrlib_15_simple_set_pyx_SimpleSet, /*tp_methods*/
  0, /*tp_members*/
  __pyx_getsets_6bzrlib_15_simple_set_pyx_SimpleSet, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pf_6bzrlib_15_simple_set_pyx_9SimpleSet___init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_6bzrlib_15_simple_set_pyx_SimpleSet, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  #if PY_VERSION_HEX >= 0x02060000
  0, /*tp_version_tag*/
  #endif
};

static PyObject *__pyx_tp_new_6bzrlib_15_simple_set_pyx__SimpleSet_iterator(PyTypeObject *t, PyObject *a, PyObject *k) {
  struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *p;
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (!o) return 0;
  p = ((struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)o);
  p->set = ((struct SimpleSetObject *)Py_None); Py_INCREF(Py_None);
  return o;
}

static void __pyx_tp_dealloc_6bzrlib_15_simple_set_pyx__SimpleSet_iterator(PyObject *o) {
  struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *p = (struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)o;
  Py_XDECREF(((PyObject *)p->set));
  (*Py_TYPE(o)->tp_free)(o);
}

static int __pyx_tp_traverse_6bzrlib_15_simple_set_pyx__SimpleSet_iterator(PyObject *o, visitproc v, void *a) {
  int e;
  struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *p = (struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)o;
  if (p->set) {
    e = (*v)(((PyObject*)p->set), a); if (e) return e;
  }
  return 0;
}

static int __pyx_tp_clear_6bzrlib_15_simple_set_pyx__SimpleSet_iterator(PyObject *o) {
  struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *p = (struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator *)o;
  PyObject* tmp;
  tmp = ((PyObject*)p->set);
  p->set = ((struct SimpleSetObject *)Py_None); Py_INCREF(Py_None);
  Py_XDECREF(tmp);
  return 0;
}

static PyMethodDef __pyx_methods_6bzrlib_15_simple_set_pyx__SimpleSet_iterator[] = {
  {__Pyx_NAMESTR("__next__"), (PyCFunction)__pyx_pf_6bzrlib_15_simple_set_pyx_19_SimpleSet_iterator_2__next__, METH_NOARGS|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__length_hint__"), (PyCFunction)__pyx_pf_6bzrlib_15_simple_set_pyx_19_SimpleSet_iterator_3__length_hint__, METH_NOARGS, __Pyx_DOCSTR(0)},
  {0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number__SimpleSet_iterator = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_divide*/
  #endif
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_coerce*/
  #endif
  0, /*nb_int*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_long*/
  #else
  0, /*reserved*/
  #endif
  0, /*nb_float*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_oct*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*nb_hex*/
  #endif
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_inplace_divide*/
  #endif
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if PY_VERSION_HEX >= 0x02050000
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence__SimpleSet_iterator = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping__SimpleSet_iterator = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer__SimpleSet_iterator = {
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getreadbuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getwritebuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getsegcount*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getcharbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_getbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_releasebuffer*/
  #endif
};

static PyTypeObject __pyx_type_6bzrlib_15_simple_set_pyx__SimpleSet_iterator = {
  PyVarObject_HEAD_INIT(0, 0)
  __Pyx_NAMESTR("bzrlib._simple_set_pyx._SimpleSet_iterator"), /*tp_name*/
  sizeof(struct __pyx_obj_6bzrlib_15_simple_set_pyx__SimpleSet_iterator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_6bzrlib_15_simple_set_pyx__SimpleSet_iterator, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  #if PY_MAJOR_VERSION < 3
  0, /*tp_compare*/
  #else
  0, /*reserved*/
  #endif
  0, /*tp_repr*/
  &__pyx_tp_as_number__SimpleSet_iterator, /*tp_as_number*/
  &__pyx_tp_as_sequence__SimpleSet_iterator, /*tp_as_sequence*/
  &__pyx_tp_as_mapping__SimpleSet_iterator, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer__SimpleSet_iterator, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_HAVE_NEWBUFFER|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_GC, /*tp_flags*/
  __Pyx_DOCSTR("Iterator over the SimpleSet structure."), /*tp_doc*/
  __pyx_tp_traverse_6bzrlib_15_simple_set_pyx__SimpleSet_iterator, /*tp_traverse*/
  __pyx_tp_clear_6bzrlib_15_simple_set_pyx__SimpleSet_iterator, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pf_6bzrlib_15_simple_set_pyx_19_SimpleSet_iterator_1__iter__, /*tp_iter*/
  __pyx_pf_6bzrlib_15_simple_set_pyx_19_SimpleSet_iterator_2__next__, /*tp_iternext*/
  __pyx_methods_6bzrlib_15_simple_set_pyx__SimpleSet_iterator, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  __pyx_pf_6bzrlib_15_simple_set_pyx_19_SimpleSet_iterator___init__, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_6bzrlib_15_simple_set_pyx__SimpleSet_iterator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
  0, /*tp_del*/
  #if PY_VERSION_HEX >= 0x02060000
  0, /*tp_version_tag*/
  #endif
};

static PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
    PyModuleDef_HEAD_INIT,
    __Pyx_NAMESTR("_simple_set_pyx"),
    __Pyx_DOCSTR(__pyx_k_14), /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp_s_1, __pyx_k_1, sizeof(__pyx_k_1), 0, 0, 1, 0},
  {&__pyx_kp_s_10, __pyx_k_10, sizeof(__pyx_k_10), 0, 0, 1, 0},
  {&__pyx_kp_s_12, __pyx_k_12, sizeof(__pyx_k_12), 0, 0, 1, 0},
  {&__pyx_kp_s_2, __pyx_k_2, sizeof(__pyx_k_2), 0, 0, 1, 0},
  {&__pyx_kp_s_3, __pyx_k_3, sizeof(__pyx_k_3), 0, 0, 1, 0},
  {&__pyx_kp_s_4, __pyx_k_4, sizeof(__pyx_k_4), 0, 0, 1, 0},
  {&__pyx_kp_s_6, __pyx_k_6, sizeof(__pyx_k_6), 0, 0, 1, 0},
  {&__pyx_kp_s_8, __pyx_k_8, sizeof(__pyx_k_8), 0, 0, 1, 0},
  {&__pyx_n_s__AssertionError, __pyx_k__AssertionError, sizeof(__pyx_k__AssertionError), 0, 0, 1, 1},
  {&__pyx_n_s__KeyError, __pyx_k__KeyError, sizeof(__pyx_k__KeyError), 0, 0, 1, 1},
  {&__pyx_n_s__MemoryError, __pyx_k__MemoryError, sizeof(__pyx_k__MemoryError), 0, 0, 1, 1},
  {&__pyx_n_s__NotImplemented, __pyx_k__NotImplemented, sizeof(__pyx_k__NotImplemented), 0, 0, 1, 1},
  {&__pyx_n_s__RuntimeError, __pyx_k__RuntimeError, sizeof(__pyx_k__RuntimeError), 0, 0, 1, 1},
  {&__pyx_n_s__StopIteration, __pyx_k__StopIteration, sizeof(__pyx_k__StopIteration), 0, 0, 1, 1},
  {&__pyx_n_s__TypeError, __pyx_k__TypeError, sizeof(__pyx_k__TypeError), 0, 0, 1, 1},
  {&__pyx_n_s____main__, __pyx_k____main__, sizeof(__pyx_k____main__), 0, 0, 1, 1},
  {&__pyx_n_s____test__, __pyx_k____test__, sizeof(__pyx_k____test__), 0, 0, 1, 1},
  {&__pyx_n_s___add, __pyx_k___add, sizeof(__pyx_k___add), 0, 0, 1, 1},
  {&__pyx_n_s___discard, __pyx_k___discard, sizeof(__pyx_k___discard), 0, 0, 1, 1},
  {&__pyx_n_s___fill, __pyx_k___fill, sizeof(__pyx_k___fill), 0, 0, 1, 1},
  {&__pyx_n_s___get, __pyx_k___get, sizeof(__pyx_k___get), 0, 0, 1, 1},
  {&__pyx_n_s___insert_clean, __pyx_k___insert_clean, sizeof(__pyx_k___insert_clean), 0, 0, 1, 1},
  {&__pyx_n_s___mask, __pyx_k___mask, sizeof(__pyx_k___mask), 0, 0, 1, 1},
  {&__pyx_n_s___resize, __pyx_k___resize, sizeof(__pyx_k___resize), 0, 0, 1, 1},
  {&__pyx_n_s___table, __pyx_k___table, sizeof(__pyx_k___table), 0, 0, 1, 1},
  {&__pyx_n_s___used, __pyx_k___used, sizeof(__pyx_k___used), 0, 0, 1, 1},
  {&__pyx_n_s__len, __pyx_k__len, sizeof(__pyx_k__len), 0, 0, 1, 1},
  {&__pyx_n_s__obj, __pyx_k__obj, sizeof(__pyx_k__obj), 0, 0, 1, 1},
  {&__pyx_n_s__object, __pyx_k__object, sizeof(__pyx_k__object), 0, 0, 1, 1},
  {&__pyx_n_s__pos, __pyx_k__pos, sizeof(__pyx_k__pos), 0, 0, 1, 1},
  {&__pyx_n_s__set, __pyx_k__set, sizeof(__pyx_k__set), 0, 0, 1, 1},
  {&__pyx_n_s__tp_hash, __pyx_k__tp_hash, sizeof(__pyx_k__tp_hash), 0, 0, 1, 1},
  {&__pyx_n_s__tp_richcompare, __pyx_k__tp_richcompare, sizeof(__pyx_k__tp_richcompare), 0, 0, 1, 1},
  {&__pyx_n_s__tp_traverse, __pyx_k__tp_traverse, sizeof(__pyx_k__tp_traverse), 0, 0, 1, 1},
  {0, 0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_object = __Pyx_GetName(__pyx_b, __pyx_n_s__object); if (!__pyx_builtin_object) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 54; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_NotImplemented = __Pyx_GetName(__pyx_b, __pyx_n_s__NotImplemented); if (!__pyx_builtin_NotImplemented) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 59; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_MemoryError = __Pyx_GetName(__pyx_b, __pyx_n_s__MemoryError); if (!__pyx_builtin_MemoryError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 115; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_KeyError = __Pyx_GetName(__pyx_b, __pyx_n_s__KeyError); if (!__pyx_builtin_KeyError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 192; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_RuntimeError = __Pyx_GetName(__pyx_b, __pyx_n_s__RuntimeError); if (!__pyx_builtin_RuntimeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_TypeError = __Pyx_GetName(__pyx_b, __pyx_n_s__TypeError); if (!__pyx_builtin_TypeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_StopIteration = __Pyx_GetName(__pyx_b, __pyx_n_s__StopIteration); if (!__pyx_builtin_StopIteration) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 383; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_AssertionError = __Pyx_GetName(__pyx_b, __pyx_n_s__AssertionError); if (!__pyx_builtin_AssertionError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitCachedConstants(void) {
  __Pyx_RefNannySetupContext("__Pyx_InitCachedConstants");

  /* "bzrlib/_simple_set_pyx.pyx":221
 *                 return 1
 *             i = i + 1 + n_lookup
 *         raise RuntimeError('ran out of slots.')             # <<<<<<<<<<<<<<
 * 
 *     def _py_resize(self, min_used):
 */
  __pyx_k_tuple_5 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_5));
  __Pyx_INCREF(((PyObject *)__pyx_kp_s_4));
  PyTuple_SET_ITEM(__pyx_k_tuple_5, 0, ((PyObject *)__pyx_kp_s_4));
  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_4));
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_5));

  /* "bzrlib/_simple_set_pyx.pyx":296
 *         if (Py_TYPE(py_key).tp_richcompare == NULL
 *             or Py_TYPE(py_key).tp_hash == NULL):
 *             raise TypeError('Types added to SimpleSet must implement'             # <<<<<<<<<<<<<<
 *                             ' both tp_richcompare and tp_hash')
 *         added = 0
 */
  __pyx_k_tuple_7 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_7));
  __Pyx_INCREF(((PyObject *)__pyx_kp_s_6));
  PyTuple_SET_ITEM(__pyx_k_tuple_7, 0, ((PyObject *)__pyx_kp_s_6));
  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_6));
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_7));

  /* "bzrlib/_simple_set_pyx.pyx":387
 *             # Force this exception to continue to be raised
 *             self._used = -1
 *             raise RuntimeError("Set size changed during iteration")             # <<<<<<<<<<<<<<
 *         if not SimpleSet_Next(self.set, &self.pos, &key):
 *             self.set = None
 */
  __pyx_k_tuple_9 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_9)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 387; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_9));
  __Pyx_INCREF(((PyObject *)__pyx_kp_s_8));
  PyTuple_SET_ITEM(__pyx_k_tuple_9, 0, ((PyObject *)__pyx_kp_s_8));
  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_8));
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_9));

  /* "bzrlib/_simple_set_pyx.pyx":418
 *     cdef SimpleSet true_self
 *     if self is None:
 *         raise TypeError('self must not be None')             # <<<<<<<<<<<<<<
 *     true_self = self
 *     return true_self
 */
  __pyx_k_tuple_11 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_11)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 418; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_11));
  __Pyx_INCREF(((PyObject *)__pyx_kp_s_10));
  PyTuple_SET_ITEM(__pyx_k_tuple_11, 0, ((PyObject *)__pyx_kp_s_10));
  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_10));
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_11));

  /* "bzrlib/_simple_set_pyx.pyx":492
 *             return slot
 *         i = i + 1 + n_lookup
 *     raise AssertionError('should never get here')             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_k_tuple_13 = PyTuple_New(1); if (unlikely(!__pyx_k_tuple_13)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 492; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_k_tuple_13));
  __Pyx_INCREF(((PyObject *)__pyx_kp_s_12));
  PyTuple_SET_ITEM(__pyx_k_tuple_13, 0, ((PyObject *)__pyx_kp_s_12));
  __Pyx_GIVEREF(((PyObject *)__pyx_kp_s_12));
  __Pyx_GIVEREF(((PyObject *)__pyx_k_tuple_13));
  __Pyx_RefNannyFinishContext();
  return 0;
  __pyx_L1_error:;
  __Pyx_RefNannyFinishContext();
  return -1;
}

static int __Pyx_InitGlobals(void) {
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC init_simple_set_pyx(void); /*proto*/
PyMODINIT_FUNC init_simple_set_pyx(void)
#else
PyMODINIT_FUNC PyInit__simple_set_pyx(void); /*proto*/
PyMODINIT_FUNC PyInit__simple_set_pyx(void)
#endif
{
  PyObject *__pyx_t_1 = NULL;
  #if CYTHON_REFNANNY
  void* __pyx_refnanny = NULL;
  __Pyx_RefNanny = __Pyx_RefNannyImportAPI("refnanny");
  if (!__Pyx_RefNanny) {
      PyErr_Clear();
      __Pyx_RefNanny = __Pyx_RefNannyImportAPI("Cython.Runtime.refnanny");
      if (!__Pyx_RefNanny)
          Py_FatalError("failed to import 'refnanny' module");
  }
  __pyx_refnanny = __Pyx_RefNanny->SetupContext("PyMODINIT_FUNC PyInit__simple_set_pyx(void)", __LINE__, __FILE__);
  #endif
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_empty_bytes = PyBytes_FromStringAndSize("", 0); if (unlikely(!__pyx_empty_bytes)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #ifdef __pyx_binding_PyCFunctionType_USED
  if (__pyx_binding_PyCFunctionType_init() < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  #endif
  /*--- Library function declarations ---*/
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("_simple_set_pyx"), __pyx_methods, __Pyx_DOCSTR(__pyx_k_14), 0, PYTHON_API_VERSION);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (!__pyx_m) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  #if PY_MAJOR_VERSION < 3
  Py_INCREF(__pyx_m);
  #endif
  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME));
  if (!__pyx_b) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  /*--- Initialize various global constants etc. ---*/
  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_module_is_main_bzrlib___simple_set_pyx) {
    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_n_s____main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  }
  /*--- Builtin init code ---*/
  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Constants init code ---*/
  if (unlikely(__Pyx_InitCachedConstants() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Global init code ---*/
  __pyx_v_6bzrlib_15_simple_set_pyx__dummy_obj = Py_None; Py_INCREF(Py_None);
  __pyx_v_6bzrlib_15_simple_set_pyx__NotImplemented = Py_None; Py_INCREF(Py_None);
  /*--- Function export code ---*/
  if (__Pyx_ExportFunction("SimpleSet_New", (void (*)(void))SimpleSet_New, "struct SimpleSetObject *(void)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("SimpleSet_Add", (void (*)(void))SimpleSet_Add, "PyObject *(PyObject *, PyObject *)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("SimpleSet_Contains", (void (*)(void))SimpleSet_Contains, "int (PyObject *, PyObject *)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("SimpleSet_Discard", (void (*)(void))SimpleSet_Discard, "int (PyObject *, PyObject *)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("SimpleSet_Get", (void (*)(void))SimpleSet_Get, "PyObject *(struct SimpleSetObject *, PyObject *)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("SimpleSet_Size", (void (*)(void))SimpleSet_Size, "Py_ssize_t (PyObject *)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("SimpleSet_Next", (void (*)(void))SimpleSet_Next, "int (PyObject *, Py_ssize_t *, PyObject **)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_ExportFunction("_SimpleSet_Lookup", (void (*)(void))_SimpleSet_Lookup, "PyObject **(PyObject *, PyObject *)") < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Type init code ---*/
  __pyx_vtabptr_6bzrlib_15_simple_set_pyx_SimpleSet = &__pyx_vtable_6bzrlib_15_simple_set_pyx_SimpleSet;
  __pyx_vtable_6bzrlib_15_simple_set_pyx_SimpleSet._get = (PyObject *(*)(struct SimpleSetObject *, PyObject *))__pyx_f_6bzrlib_15_simple_set_pyx_9SimpleSet__get;
  __pyx_vtable_6bzrlib_15_simple_set_pyx_SimpleSet._add = (PyObject *(*)(struct SimpleSetObject *, PyObject *))__pyx_f_6bzrlib_15_simple_set_pyx_9SimpleSet__add;
  __pyx_vtable_6bzrlib_15_simple_set_pyx_SimpleSet._discard = (int (*)(struct SimpleSetObject *, PyObject *))__pyx_f_6bzrlib_15_simple_set_pyx_9SimpleSet__discard;
  __pyx_vtable_6bzrlib_15_simple_set_pyx_SimpleSet._insert_clean = (int (*)(struct SimpleSetObject *, PyObject *))__pyx_f_6bzrlib_15_simple_set_pyx_9SimpleSet__insert_clean;
  __pyx_vtable_6bzrlib_15_simple_set_pyx_SimpleSet._resize = (Py_ssize_t (*)(struct SimpleSetObject *, Py_ssize_t))__pyx_f_6bzrlib_15_simple_set_pyx_9SimpleSet__resize;
  if (PyType_Ready(&SimpleSet_Type) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 88; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  {
    PyObject *wrapper = __Pyx_GetAttrString((PyObject *)&SimpleSet_Type, "__contains__"); if (unlikely(!wrapper)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 88; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_6bzrlib_15_simple_set_pyx_9SimpleSet_6__contains__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_6bzrlib_15_simple_set_pyx_9SimpleSet_6__contains__.doc = __pyx_doc_6bzrlib_15_simple_set_pyx_9SimpleSet_6__contains__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_6bzrlib_15_simple_set_pyx_9SimpleSet_6__contains__;
    }
  }
  {
    PyObject *wrapper = __Pyx_GetAttrString((PyObject *)&SimpleSet_Type, "__getitem__"); if (unlikely(!wrapper)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 88; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (Py_TYPE(wrapper) == &PyWrapperDescr_Type) {
      __pyx_wrapperbase_6bzrlib_15_simple_set_pyx_9SimpleSet_7__getitem__ = *((PyWrapperDescrObject *)wrapper)->d_base;
      __pyx_wrapperbase_6bzrlib_15_simple_set_pyx_9SimpleSet_7__getitem__.doc = __pyx_doc_6bzrlib_15_simple_set_pyx_9SimpleSet_7__getitem__;
      ((PyWrapperDescrObject *)wrapper)->d_base = &__pyx_wrapperbase_6bzrlib_15_simple_set_pyx_9SimpleSet_7__getitem__;
    }
  }
  if (__Pyx_SetVtable(SimpleSet_Type.tp_dict, __pyx_vtabptr_6bzrlib_15_simple_set_pyx_SimpleSet) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 88; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_SetAttrString(__pyx_m, "SimpleSet", (PyObject *)&SimpleSet_Type) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 88; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6bzrlib_15_simple_set_pyx_SimpleSet = &SimpleSet_Type;
  if (PyType_Ready(&__pyx_type_6bzrlib_15_simple_set_pyx__SimpleSet_iterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_SetAttrString(__pyx_m, "_SimpleSet_iterator", (PyObject *)&__pyx_type_6bzrlib_15_simple_set_pyx__SimpleSet_iterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_6bzrlib_15_simple_set_pyx__SimpleSet_iterator = &__pyx_type_6bzrlib_15_simple_set_pyx__SimpleSet_iterator;
  /*--- Type import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/

  /* "bzrlib/_simple_set_pyx.pyx":54
 * cdef object _dummy_obj
 * cdef PyObject *_dummy
 * _dummy_obj = object()             # <<<<<<<<<<<<<<
 * _dummy = <PyObject *>_dummy_obj
 * 
 */
  __pyx_t_1 = PyObject_Call(__pyx_builtin_object, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 54; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_GOTREF(__pyx_v_6bzrlib_15_simple_set_pyx__dummy_obj);
  __Pyx_DECREF(__pyx_v_6bzrlib_15_simple_set_pyx__dummy_obj);
  __Pyx_GIVEREF(__pyx_t_1);
  __pyx_v_6bzrlib_15_simple_set_pyx__dummy_obj = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "bzrlib/_simple_set_pyx.pyx":55
 * cdef PyObject *_dummy
 * _dummy_obj = object()
 * _dummy = <PyObject *>_dummy_obj             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __pyx_v_6bzrlib_15_simple_set_pyx__dummy = ((PyObject *)__pyx_v_6bzrlib_15_simple_set_pyx__dummy_obj);

  /* "bzrlib/_simple_set_pyx.pyx":59
 * 
 * cdef object _NotImplemented
 * _NotImplemented = NotImplemented             # <<<<<<<<<<<<<<
 * 
 * 
 */
  __Pyx_INCREF(__pyx_builtin_NotImplemented);
  __Pyx_GOTREF(__pyx_v_6bzrlib_15_simple_set_pyx__NotImplemented);
  __Pyx_DECREF(__pyx_v_6bzrlib_15_simple_set_pyx__NotImplemented);
  __Pyx_GIVEREF(__pyx_builtin_NotImplemented);
  __pyx_v_6bzrlib_15_simple_set_pyx__NotImplemented = __pyx_builtin_NotImplemented;

  /* "bzrlib/_simple_set_pyx.pyx":606
 * # It is a little bit ugly to do this, but it works, and means that Meliae can
 * # dump the total memory consumed by all child objects.
 * (<PyTypeObject *>SimpleSet).tp_traverse = <traverseproc>SimpleSet_traverse             # <<<<<<<<<<<<<<
 */
  ((PyTypeObject *)((PyObject*)__pyx_ptype_6bzrlib_15_simple_set_pyx_SimpleSet))->tp_traverse = ((traverseproc)__pyx_f_6bzrlib_15_simple_set_pyx_SimpleSet_traverse);

  /* "bzrlib/_simple_set_pyx.pyx":1
 * # Copyright (C) 2009, 2010 Canonical Ltd             # <<<<<<<<<<<<<<
 * #
 * # This program is free software; you can redistribute it and/or modify
 */
  __pyx_t_1 = PyDict_New(); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  if (PyObject_SetAttr(__pyx_m, __pyx_n_s____test__, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  if (__pyx_m) {
    __Pyx_AddTraceback("init bzrlib._simple_set_pyx");
    Py_DECREF(__pyx_m); __pyx_m = 0;
  } else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_ImportError, "init bzrlib._simple_set_pyx");
  }
  __pyx_L0:;
  __Pyx_RefNannyFinishContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

/* Runtime support code */

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name) {
    PyObject *result;
    result = PyObject_GetAttr(dict, name);
    if (!result)
        PyErr_SetObject(PyExc_NameError, name);
    return result;
}

static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *number, *more_or_less;

    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    number = (num_expected == 1) ? "" : "s";
    PyErr_Format(PyExc_TypeError,
        #if PY_VERSION_HEX < 0x02050000
            "%s() takes %s %d positional argument%s (%d given)",
        #else
            "%s() takes %s %zd positional argument%s (%zd given)",
        #endif
        func_name, more_or_less, num_expected, number, num_found);
}

static CYTHON_INLINE int __Pyx_CheckKeywordStrings(
    PyObject *kwdict,
    const char* function_name,
    int kw_allowed)
{
    PyObject* key = 0;
    Py_ssize_t pos = 0;
    while (PyDict_Next(kwdict, &pos, &key, 0)) {
        #if PY_MAJOR_VERSION < 3
        if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key)))
        #else
        if (unlikely(!PyUnicode_CheckExact(key)) && unlikely(!PyUnicode_Check(key)))
        #endif
            goto invalid_keyword_type;
    }
    if ((!kw_allowed) && unlikely(key))
        goto invalid_keyword;
    return 1;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%s() keywords must be strings", function_name);
    return 0;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%s() got an unexpected keyword argument '%s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
    return 0;
}

static CYTHON_INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();

    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}

static CYTHON_INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;

    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}


#if PY_MAJOR_VERSION < 3
static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb) {
    Py_XINCREF(type);
    Py_XINCREF(value);
    Py_XINCREF(tb);
    /* First, check the traceback argument, replacing None with NULL. */
    if (tb == Py_None) {
        Py_DECREF(tb);
        tb = 0;
    }
    else if (tb != NULL && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto raise_error;
    }
    /* Next, replace a missing value with None */
    if (value == NULL) {
        value = Py_None;
        Py_INCREF(value);
    }
    #if PY_VERSION_HEX < 0x02050000
    if (!PyClass_Check(type))
    #else
    if (!PyType_Check(type))
    #endif
    {
        /* Raising an instance.  The value should be a dummy. */
        if (value != Py_None) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        /* Normalize to raise <class>, <instance> */
        Py_DECREF(value);
        value = type;
        #if PY_VERSION_HEX < 0x02050000
            if (PyInstance_Check(type)) {
                type = (PyObject*) ((PyInstanceObject*)type)->in_class;
                Py_INCREF(type);
            }
            else {
                type = 0;
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception must be an old-style class or instance");
                goto raise_error;
            }
        #else
            type = (PyObject*) Py_TYPE(type);
            Py_INCREF(type);
            if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception class must be a subclass of BaseException");
                goto raise_error;
            }
        #endif
    }

    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}

#else /* Python 3+ */

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb) {
    if (tb == Py_None) {
        tb = 0;
    } else if (tb && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto bad;
    }
    if (value == Py_None)
        value = 0;

    if (PyExceptionInstance_Check(type)) {
        if (value) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto bad;
        }
        value = type;
        type = (PyObject*) Py_TYPE(value);
    } else if (!PyExceptionClass_Check(type)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: exception class must be a subclass of BaseException");
        goto bad;
    }

    PyErr_SetObject(type, value);

    if (tb) {
        PyThreadState *tstate = PyThreadState_GET();
        PyObject* tmp_tb = tstate->curexc_traceback;
        if (tb != tmp_tb) {
            Py_INCREF(tb);
            tstate->curexc_traceback = tb;
            Py_XDECREF(tmp_tb);
        }
    }

bad:
    return;
}
#endif

static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AS_STRING(kw_name));
        #endif
}

static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;

    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
        } else {
            #if PY_MAJOR_VERSION < 3
            if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key))) {
            #else
            if (unlikely(!PyUnicode_CheckExact(key)) && unlikely(!PyUnicode_Check(key))) {
            #endif
                goto invalid_keyword_type;
            } else {
                for (name = first_kw_arg; *name; name++) {
                    #if PY_MAJOR_VERSION >= 3
                    if (PyUnicode_GET_SIZE(**name) == PyUnicode_GET_SIZE(key) &&
                        PyUnicode_Compare(**name, key) == 0) break;
                    #else
                    if (PyString_GET_SIZE(**name) == PyString_GET_SIZE(key) &&
                        _PyString_Eq(**name, key)) break;
                    #endif
                }
                if (*name) {
                    values[name-argnames] = value;
                } else {
                    /* unexpected keyword found */
                    for (name=argnames; name != first_kw_arg; name++) {
                        if (**name == key) goto arg_passed_twice;
                        #if PY_MAJOR_VERSION >= 3
                        if (PyUnicode_GET_SIZE(**name) == PyUnicode_GET_SIZE(key) &&
                            PyUnicode_Compare(**name, key) == 0) goto arg_passed_twice;
                        #else
                        if (PyString_GET_SIZE(**name) == PyString_GET_SIZE(key) &&
                            _PyString_Eq(**name, key)) goto arg_passed_twice;
                        #endif
                    }
                    if (kwds2) {
                        if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
                    } else {
                        goto invalid_keyword;
                    }
                }
            }
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, **name);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%s() got an unexpected keyword argument '%s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

static CYTHON_INLINE int __Pyx_TypeTest(PyObject *obj, PyTypeObject *type) {
    if (unlikely(!type)) {
        PyErr_Format(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (likely(PyObject_TypeCheck(obj, type)))
        return 1;
    PyErr_Format(PyExc_TypeError, "Cannot convert %.200s to %.200s",
                 Py_TYPE(obj)->tp_name, type->tp_name);
    return 0;
}

static CYTHON_INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
    const unsigned char neg_one = (unsigned char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned char" :
                    "value too large to convert to unsigned char");
            }
            return (unsigned char)-1;
        }
        return (unsigned char)val;
    }
    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
    const unsigned short neg_one = (unsigned short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned short" :
                    "value too large to convert to unsigned short");
            }
            return (unsigned short)-1;
        }
        return (unsigned short)val;
    }
    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
    const unsigned int neg_one = (unsigned int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(unsigned int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to unsigned int" :
                    "value too large to convert to unsigned int");
            }
            return (unsigned int)-1;
        }
        return (unsigned int)val;
    }
    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
}

static CYTHON_INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
    const char neg_one = (char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to char" :
                    "value too large to convert to char");
            }
            return (char)-1;
        }
        return (char)val;
    }
    return (char)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
    const short neg_one = (short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to short" :
                    "value too large to convert to short");
            }
            return (short)-1;
        }
        return (short)val;
    }
    return (short)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
    const int neg_one = (int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to int" :
                    "value too large to convert to int");
            }
            return (int)-1;
        }
        return (int)val;
    }
    return (int)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
    const signed char neg_one = (signed char)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed char)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed char" :
                    "value too large to convert to signed char");
            }
            return (signed char)-1;
        }
        return (signed char)val;
    }
    return (signed char)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
    const signed short neg_one = (signed short)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed short)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed short" :
                    "value too large to convert to signed short");
            }
            return (signed short)-1;
        }
        return (signed short)val;
    }
    return (signed short)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
    const signed int neg_one = (signed int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(signed int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to signed int" :
                    "value too large to convert to signed int");
            }
            return (signed int)-1;
        }
        return (signed int)val;
    }
    return (signed int)__Pyx_PyInt_AsSignedLong(x);
}

static CYTHON_INLINE int __Pyx_PyInt_AsLongDouble(PyObject* x) {
    const int neg_one = (int)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
    if (sizeof(int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(int)val)) {
            if (!unlikely(val == -1 && PyErr_Occurred())) {
                PyErr_SetString(PyExc_OverflowError,
                    (is_unsigned && unlikely(val < 0)) ?
                    "can't convert negative value to int" :
                    "value too large to convert to int");
            }
            return (int)-1;
        }
        return (int)val;
    }
    return (int)__Pyx_PyInt_AsLong(x);
}

static CYTHON_INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
    const unsigned long neg_one = (unsigned long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned long");
            return (unsigned long)-1;
        }
        return (unsigned long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to unsigned long");
                return (unsigned long)-1;
            }
            return PyLong_AsUnsignedLong(x);
        } else {
            return PyLong_AsLong(x);
        }
    } else {
        unsigned long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (unsigned long)-1;
        val = __Pyx_PyInt_AsUnsignedLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
    const unsigned PY_LONG_LONG neg_one = (unsigned PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned PY_LONG_LONG");
            return (unsigned PY_LONG_LONG)-1;
        }
        return (unsigned PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to unsigned PY_LONG_LONG");
                return (unsigned PY_LONG_LONG)-1;
            }
            return PyLong_AsUnsignedLongLong(x);
        } else {
            return PyLong_AsLongLong(x);
        }
    } else {
        unsigned PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (unsigned PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
    const long neg_one = (long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to long");
            return (long)-1;
        }
        return (long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to long");
                return (long)-1;
            }
            return PyLong_AsUnsignedLong(x);
        } else {
            return PyLong_AsLong(x);
        }
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (long)-1;
        val = __Pyx_PyInt_AsLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
    const PY_LONG_LONG neg_one = (PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to PY_LONG_LONG");
            return (PY_LONG_LONG)-1;
        }
        return (PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to PY_LONG_LONG");
                return (PY_LONG_LONG)-1;
            }
            return PyLong_AsUnsignedLongLong(x);
        } else {
            return PyLong_AsLongLong(x);
        }
    } else {
        PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
    const signed long neg_one = (signed long)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to signed long");
            return (signed long)-1;
        }
        return (signed long)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to signed long");
                return (signed long)-1;
            }
            return PyLong_AsUnsignedLong(x);
        } else {
            return PyLong_AsLong(x);
        }
    } else {
        signed long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (signed long)-1;
        val = __Pyx_PyInt_AsSignedLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static CYTHON_INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
    const signed PY_LONG_LONG neg_one = (signed PY_LONG_LONG)-1, const_zero = 0;
    const int is_unsigned = neg_one > const_zero;
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (is_unsigned && unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to signed PY_LONG_LONG");
            return (signed PY_LONG_LONG)-1;
        }
        return (signed PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_Check(x))) {
        if (is_unsigned) {
            if (unlikely(Py_SIZE(x) < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to signed PY_LONG_LONG");
                return (signed PY_LONG_LONG)-1;
            }
            return PyLong_AsUnsignedLongLong(x);
        } else {
            return PyLong_AsLongLong(x);
        }
    } else {
        signed PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (signed PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsSignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static int __Pyx_ExportFunction(const char *name, void (*f)(void), const char *sig) {
    PyObject *d = 0;
    PyObject *cobj = 0;
    union {
        void (*fp)(void);
        void *p;
    } tmp;

    d = PyObject_GetAttrString(__pyx_m, (char *)"__pyx_capi__");
    if (!d) {
        PyErr_Clear();
        d = PyDict_New();
        if (!d)
            goto bad;
        Py_INCREF(d);
        if (PyModule_AddObject(__pyx_m, (char *)"__pyx_capi__", d) < 0)
            goto bad;
    }
    tmp.fp = f;
#if PY_VERSION_HEX >= 0x02070000 && !(PY_MAJOR_VERSION==3&&PY_MINOR_VERSION==0)
    cobj = PyCapsule_New(tmp.p, sig, 0);
#else
    cobj = PyCObject_FromVoidPtrAndDesc(tmp.p, (void *)sig, 0);
#endif
    if (!cobj)
        goto bad;
    if (PyDict_SetItemString(d, name, cobj) < 0)
        goto bad;
    Py_DECREF(cobj);
    Py_DECREF(d);
    return 0;
bad:
    Py_XDECREF(cobj);
    Py_XDECREF(d);
    return -1;
}

static int __Pyx_SetVtable(PyObject *dict, void *vtable) {
#if PY_VERSION_HEX >= 0x02070000 && !(PY_MAJOR_VERSION==3&&PY_MINOR_VERSION==0)
    PyObject *ob = PyCapsule_New(vtable, 0, 0);
#else
    PyObject *ob = PyCObject_FromVoidPtr(vtable, 0);
#endif
    if (!ob)
        goto bad;
    if (PyDict_SetItemString(dict, "__pyx_vtable__", ob) < 0)
        goto bad;
    Py_DECREF(ob);
    return 0;
bad:
    Py_XDECREF(ob);
    return -1;
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"

static void __Pyx_AddTraceback(const char *funcname) {
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    PyObject *py_globals = 0;
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;

    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(__pyx_filename);
    #else
    py_srcfile = PyUnicode_FromString(__pyx_filename);
    #endif
    if (!py_srcfile) goto bad;
    if (__pyx_clineno) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, __pyx_clineno);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, __pyx_clineno);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_globals = PyModule_GetDict(__pyx_m);
    if (!py_globals) goto bad;
    py_code = PyCode_New(
        0,            /*int argcount,*/
        #if PY_MAJOR_VERSION >= 3
        0,            /*int kwonlyargcount,*/
        #endif
        0,            /*int nlocals,*/
        0,            /*int stacksize,*/
        0,            /*int flags,*/
        __pyx_empty_bytes, /*PyObject *code,*/
        __pyx_empty_tuple,  /*PyObject *consts,*/
        __pyx_empty_tuple,  /*PyObject *names,*/
        __pyx_empty_tuple,  /*PyObject *varnames,*/
        __pyx_empty_tuple,  /*PyObject *freevars,*/
        __pyx_empty_tuple,  /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        __pyx_lineno,   /*int firstlineno,*/
        __pyx_empty_bytes  /*PyObject *lnotab*/
    );
    if (!py_code) goto bad;
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        py_globals,          /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = __pyx_lineno;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else  /* Python 3+ has unicode identifiers */
        if (t->is_unicode | t->is_str) {
            if (t->intern) {
                *t->p = PyUnicode_InternFromString(t->s);
            } else if (t->encoding) {
                *t->p = PyUnicode_Decode(t->s, t->n - 1, t->encoding, NULL);
            } else {
                *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
            }
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

/* Type Conversion Functions */

static CYTHON_INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   int is_true = x == Py_True;
   if (is_true | (x == Py_False) | (x == Py_None)) return is_true;
   else return PyObject_IsTrue(x);
}

static CYTHON_INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
  PyNumberMethods *m;
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return Py_INCREF(x), x;
  m = Py_TYPE(x)->tp_as_number;
#if PY_VERSION_HEX < 0x03000000
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
#else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
#endif
  if (res) {
#if PY_VERSION_HEX < 0x03000000
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%s__ returned non-%s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}

static CYTHON_INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject* x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}

static CYTHON_INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
#if PY_VERSION_HEX < 0x02050000
   if (ival <= LONG_MAX)
       return PyInt_FromLong((long)ival);
   else {
       unsigned char *bytes = (unsigned char *) &ival;
       int one = 1; int little = (int)*(unsigned char*)&one;
       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
   }
#else
   return PyInt_FromSize_t(ival);
#endif
}

static CYTHON_INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
   if (unlikely(val == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())) {
       return (size_t)-1;
   } else if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
       PyErr_SetString(PyExc_OverflowError,
                       "value too large to convert to size_t");
       return (size_t)-1;
   }
   return (size_t)val;
}


#endif /* Py_PYTHON_H */
